// @generated by protobuf-ts 2.9.4 with parameter client_generic
// @generated from protobuf file "sushi_rpc.proto" (package "sushi_rpc", syntax proto3)
// tslint:disable
//
//* gRPC definitions for external control of sushi
//
// @copyright 2018 - 2022 Modern Ancient Instruments Networked AB, dba Elk, Stockholm
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// *
// Global wrappers for primitive types.
// 
// gRPC requires the usage of custom messages as arguments/return types of services,
// and it is good practice to define custom values for better future expansion of the
// protocol.
// 
// However, this leads to unnecessary bloat especially for cases where it's clear
// that a primitive type is the best choice (e.g. GetNumSomething), so we define here
// some common cases to all services.

/**
 * @generated from protobuf message sushi_rpc.GenericVoidValue
 */
export interface GenericVoidValue {
}
/**
 * @generated from protobuf message sushi_rpc.GenericFloatValue
 */
export interface GenericFloatValue {
    /**
     * @generated from protobuf field: float value = 1;
     */
    value: number;
}
/**
 * @generated from protobuf message sushi_rpc.GenericIntValue
 */
export interface GenericIntValue {
    /**
     * @generated from protobuf field: int32 value = 1;
     */
    value: number;
}
/**
 * @generated from protobuf message sushi_rpc.GenericBoolValue
 */
export interface GenericBoolValue {
    /**
     * @generated from protobuf field: bool value = 1;
     */
    value: boolean;
}
/**
 * @generated from protobuf message sushi_rpc.GenericStringValue
 */
export interface GenericStringValue {
    /**
     * @generated from protobuf field: string value = 1;
     */
    value: string;
}
/**
 * @generated from protobuf message sushi_rpc.OptionalBoolValue
 */
export interface OptionalBoolValue {
    /**
     * @generated from protobuf field: bool has_value = 1;
     */
    hasValue: boolean;
    /**
     * @generated from protobuf field: bool value = 2;
     */
    value: boolean;
}
/**
 * @generated from protobuf message sushi_rpc.OptionalIntValue
 */
export interface OptionalIntValue {
    /**
     * @generated from protobuf field: bool has_value = 1;
     */
    hasValue: boolean;
    /**
     * @generated from protobuf field: int32 value = 2;
     */
    value: number;
}
// Common types 

/**
 * @generated from protobuf message sushi_rpc.SushiBuildInfo
 */
export interface SushiBuildInfo {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
    /**
     * @generated from protobuf field: repeated string build_options = 2;
     */
    buildOptions: string[];
    /**
     * @generated from protobuf field: int32 audio_buffer_size = 3;
     */
    audioBufferSize: number;
    /**
     * @generated from protobuf field: string commit_hash = 4;
     */
    commitHash: string;
    /**
     * @generated from protobuf field: string build_date = 5;
     */
    buildDate: string;
}
/**
 * @generated from protobuf message sushi_rpc.TrackIdentifier
 */
export interface TrackIdentifier {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
}
/**
 * @generated from protobuf message sushi_rpc.ProcessorIdentifier
 */
export interface ProcessorIdentifier {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
}
/**
 * @generated from protobuf message sushi_rpc.ParameterIdentifier
 */
export interface ParameterIdentifier {
    /**
     * @generated from protobuf field: int32 processor_id = 1;
     */
    processorId: number;
    /**
     * @generated from protobuf field: int32 parameter_id = 2;
     */
    parameterId: number;
}
/**
 * @generated from protobuf message sushi_rpc.PropertyIdentifier
 */
export interface PropertyIdentifier {
    /**
     * @generated from protobuf field: int32 processor_id = 1;
     */
    processorId: number;
    /**
     * @generated from protobuf field: int32 property_id = 2;
     */
    propertyId: number;
}
/**
 * 0 is reserved for "not set" in protobuf, so we don't use it for a valid response
 *
 * @generated from protobuf message sushi_rpc.ParameterType
 */
export interface ParameterType {
    /**
     * @generated from protobuf field: sushi_rpc.ParameterType.Type type = 1;
     */
    type: ParameterType_Type;
}
/**
 * @generated from protobuf enum sushi_rpc.ParameterType.Type
 */
export enum ParameterType_Type {
    /**
     * @generated from protobuf enum value: DUMMY = 0;
     */
    DUMMY = 0,
    /**
     * @generated from protobuf enum value: BOOL = 1;
     */
    BOOL = 1,
    /**
     * @generated from protobuf enum value: INT = 2;
     */
    INT = 2,
    /**
     * @generated from protobuf enum value: FLOAT = 3;
     */
    FLOAT = 3
}
// Messages 

/**
 * @generated from protobuf message sushi_rpc.PlayingMode
 */
export interface PlayingMode {
    /**
     * @generated from protobuf field: sushi_rpc.PlayingMode.Mode mode = 1;
     */
    mode: PlayingMode_Mode;
}
/**
 * @generated from protobuf enum sushi_rpc.PlayingMode.Mode
 */
export enum PlayingMode_Mode {
    /**
     * @generated from protobuf enum value: DUMMY = 0;
     */
    DUMMY = 0,
    /**
     * @generated from protobuf enum value: STOPPED = 1;
     */
    STOPPED = 1,
    /**
     * @generated from protobuf enum value: PLAYING = 2;
     */
    PLAYING = 2,
    /**
     * @generated from protobuf enum value: RECORDING = 3;
     */
    RECORDING = 3
}
/**
 * @generated from protobuf message sushi_rpc.SyncMode
 */
export interface SyncMode {
    /**
     * @generated from protobuf field: sushi_rpc.SyncMode.Mode mode = 1;
     */
    mode: SyncMode_Mode;
}
/**
 * @generated from protobuf enum sushi_rpc.SyncMode.Mode
 */
export enum SyncMode_Mode {
    /**
     * @generated from protobuf enum value: DUMMY = 0;
     */
    DUMMY = 0,
    /**
     * @generated from protobuf enum value: INTERNAL = 1;
     */
    INTERNAL = 1,
    /**
     * @generated from protobuf enum value: MIDI = 2;
     */
    MIDI = 2,
    /**
     * @generated from protobuf enum value: LINK = 3;
     */
    LINK = 3
}
/**
 * @generated from protobuf message sushi_rpc.TimeSignature
 */
export interface TimeSignature {
    /**
     * @generated from protobuf field: int32 numerator = 1;
     */
    numerator: number;
    /**
     * @generated from protobuf field: int32 denominator = 2;
     */
    denominator: number;
}
/**
 * @generated from protobuf message sushi_rpc.CpuTimings
 */
export interface CpuTimings {
    /**
     * @generated from protobuf field: float average = 1;
     */
    average: number;
    /**
     * @generated from protobuf field: float min = 2;
     */
    min: number;
    /**
     * @generated from protobuf field: float max = 3;
     */
    max: number;
}
/**
 * @generated from protobuf message sushi_rpc.NoteOnRequest
 */
export interface NoteOnRequest {
    /**
     * @generated from protobuf field: sushi_rpc.TrackIdentifier track = 1;
     */
    track?: TrackIdentifier;
    /**
     * @generated from protobuf field: int32 channel = 2;
     */
    channel: number;
    /**
     * @generated from protobuf field: int32 note = 3;
     */
    note: number;
    /**
     * @generated from protobuf field: float velocity = 4;
     */
    velocity: number;
}
/**
 * @generated from protobuf message sushi_rpc.NoteOffRequest
 */
export interface NoteOffRequest {
    /**
     * @generated from protobuf field: sushi_rpc.TrackIdentifier track = 1;
     */
    track?: TrackIdentifier;
    /**
     * @generated from protobuf field: int32 channel = 2;
     */
    channel: number;
    /**
     * @generated from protobuf field: int32 note = 3;
     */
    note: number;
    /**
     * @generated from protobuf field: float velocity = 4;
     */
    velocity: number;
}
/**
 * @generated from protobuf message sushi_rpc.NoteAftertouchRequest
 */
export interface NoteAftertouchRequest {
    /**
     * @generated from protobuf field: sushi_rpc.TrackIdentifier track = 1;
     */
    track?: TrackIdentifier;
    /**
     * @generated from protobuf field: int32 channel = 2;
     */
    channel: number;
    /**
     * @generated from protobuf field: int32 note = 3;
     */
    note: number;
    /**
     * @generated from protobuf field: float value = 4;
     */
    value: number;
}
/**
 * @generated from protobuf message sushi_rpc.NoteModulationRequest
 */
export interface NoteModulationRequest {
    /**
     * @generated from protobuf field: sushi_rpc.TrackIdentifier track = 1;
     */
    track?: TrackIdentifier;
    /**
     * @generated from protobuf field: int32 channel = 2;
     */
    channel: number;
    /**
     * @generated from protobuf field: float value = 3;
     */
    value: number;
}
/**
 * @generated from protobuf message sushi_rpc.TrackType
 */
export interface TrackType {
    /**
     * @generated from protobuf field: sushi_rpc.TrackType.Type type = 1;
     */
    type: TrackType_Type;
}
/**
 * @generated from protobuf enum sushi_rpc.TrackType.Type
 */
export enum TrackType_Type {
    /**
     * @generated from protobuf enum value: DUMMY = 0;
     */
    DUMMY = 0,
    /**
     * @generated from protobuf enum value: REGULAR = 1;
     */
    REGULAR = 1,
    /**
     * @generated from protobuf enum value: PRE = 2;
     */
    PRE = 2,
    /**
     * @generated from protobuf enum value: POST = 3;
     */
    POST = 3
}
/**
 * @generated from protobuf message sushi_rpc.TrackInfo
 */
export interface TrackInfo {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: string label = 2;
     */
    label: string;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 channels = 4;
     */
    channels: number;
    /**
     * @generated from protobuf field: int32 buses = 5;
     */
    buses: number;
    /**
     * @generated from protobuf field: sushi_rpc.TrackType type = 6;
     */
    type?: TrackType;
    /**
     * @generated from protobuf field: repeated sushi_rpc.ProcessorIdentifier processors = 7;
     */
    processors: ProcessorIdentifier[];
}
/**
 * @generated from protobuf message sushi_rpc.TrackInfoList
 */
export interface TrackInfoList {
    /**
     * @generated from protobuf field: repeated sushi_rpc.TrackInfo tracks = 1;
     */
    tracks: TrackInfo[];
}
/**
 * @generated from protobuf message sushi_rpc.ProcessorInfo
 */
export interface ProcessorInfo {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: string label = 2;
     */
    label: string;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 parameter_count = 4;
     */
    parameterCount: number;
    /**
     * @generated from protobuf field: int32 program_count = 5;
     */
    programCount: number;
}
/**
 * @generated from protobuf message sushi_rpc.ProcessorInfoList
 */
export interface ProcessorInfoList {
    /**
     * @generated from protobuf field: repeated sushi_rpc.ProcessorInfo processors = 1;
     */
    processors: ProcessorInfo[];
}
/**
 * @generated from protobuf message sushi_rpc.ProgramIdentifier
 */
export interface ProgramIdentifier {
    /**
     * @generated from protobuf field: int32 program = 1;
     */
    program: number;
}
/**
 * @generated from protobuf message sushi_rpc.ProcessorProgramIdentifier
 */
export interface ProcessorProgramIdentifier {
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorIdentifier processor = 1;
     */
    processor?: ProcessorIdentifier;
    /**
     * @generated from protobuf field: int32 program = 2;
     */
    program: number;
}
/**
 * @generated from protobuf message sushi_rpc.ProgramInfo
 */
export interface ProgramInfo {
    /**
     * @generated from protobuf field: sushi_rpc.ProgramIdentifier id = 1;
     */
    id?: ProgramIdentifier;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message sushi_rpc.ProgramInfoList
 */
export interface ProgramInfoList {
    /**
     * @generated from protobuf field: repeated sushi_rpc.ProgramInfo programs = 1;
     */
    programs: ProgramInfo[];
}
/**
 * @generated from protobuf message sushi_rpc.ProcessorProgramSetRequest
 */
export interface ProcessorProgramSetRequest {
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorIdentifier processor = 1;
     */
    processor?: ProcessorIdentifier;
    /**
     * @generated from protobuf field: sushi_rpc.ProgramIdentifier program = 2;
     */
    program?: ProgramIdentifier;
}
/**
 * @generated from protobuf message sushi_rpc.ProcessorBypassStateSetRequest
 */
export interface ProcessorBypassStateSetRequest {
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorIdentifier processor = 1;
     */
    processor?: ProcessorIdentifier;
    /**
     * @generated from protobuf field: bool value = 2;
     */
    value: boolean;
}
/**
 * @generated from protobuf message sushi_rpc.ProcessorState
 */
export interface ProcessorState {
    /**
     * @generated from protobuf field: sushi_rpc.OptionalIntValue program_id = 1;
     */
    programId?: OptionalIntValue;
    /**
     * @generated from protobuf field: sushi_rpc.OptionalBoolValue bypassed = 2;
     */
    bypassed?: OptionalBoolValue;
    /**
     * @generated from protobuf field: repeated sushi_rpc.PropertyValue properties = 3;
     */
    properties: PropertyValue[];
    /**
     * @generated from protobuf field: repeated sushi_rpc.ParameterValue parameters = 4;
     */
    parameters: ParameterValue[];
    /**
     * @generated from protobuf field: bytes binary_data = 5;
     */
    binaryData: Uint8Array;
}
/**
 * @generated from protobuf message sushi_rpc.ProcessorStateSetRequest
 */
export interface ProcessorStateSetRequest {
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorIdentifier processor = 1;
     */
    processor?: ProcessorIdentifier;
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorState state = 2;
     */
    state?: ProcessorState;
}
/**
 * @generated from protobuf message sushi_rpc.ParameterInfo
 */
export interface ParameterInfo {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: sushi_rpc.ParameterType type = 2;
     */
    type?: ParameterType;
    /**
     * @generated from protobuf field: string label = 3;
     */
    label: string;
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
    /**
     * @generated from protobuf field: string unit = 5;
     */
    unit: string;
    /**
     * @generated from protobuf field: bool automatable = 6;
     */
    automatable: boolean;
    /**
     * @generated from protobuf field: float min_domain_value = 7;
     */
    minDomainValue: number;
    /**
     * @generated from protobuf field: float max_domain_value = 8;
     */
    maxDomainValue: number;
}
/**
 * @generated from protobuf message sushi_rpc.ParameterInfoList
 */
export interface ParameterInfoList {
    /**
     * @generated from protobuf field: repeated sushi_rpc.ParameterInfo parameters = 1;
     */
    parameters: ParameterInfo[];
}
/**
 * @generated from protobuf message sushi_rpc.ParameterIdRequest
 */
export interface ParameterIdRequest {
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorIdentifier processor = 1;
     */
    processor?: ProcessorIdentifier;
    /**
     * @generated from protobuf field: string ParameterName = 2 [json_name = "ParameterName"];
     */
    parameterName: string;
}
/**
 * @generated from protobuf message sushi_rpc.ParameterValue
 */
export interface ParameterValue {
    /**
     * @generated from protobuf field: sushi_rpc.ParameterIdentifier parameter = 1;
     */
    parameter?: ParameterIdentifier;
    /**
     * @generated from protobuf field: float value = 2;
     */
    value: number;
}
/**
 * @generated from protobuf message sushi_rpc.ParameterUpdate
 */
export interface ParameterUpdate {
    /**
     * @generated from protobuf field: sushi_rpc.ParameterIdentifier parameter = 1;
     */
    parameter?: ParameterIdentifier;
    /**
     * @generated from protobuf field: float normalized_value = 2;
     */
    normalizedValue: number;
    /**
     * @generated from protobuf field: float domain_value = 3;
     */
    domainValue: number;
    /**
     * @generated from protobuf field: string formatted_value = 4;
     */
    formattedValue: string;
}
/**
 * @generated from protobuf message sushi_rpc.PropertyInfo
 */
export interface PropertyInfo {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string label = 3;
     */
    label: string;
}
/**
 * @generated from protobuf message sushi_rpc.PropertyInfoList
 */
export interface PropertyInfoList {
    /**
     * @generated from protobuf field: repeated sushi_rpc.PropertyInfo properties = 1;
     */
    properties: PropertyInfo[];
}
/**
 * @generated from protobuf message sushi_rpc.PropertyValue
 */
export interface PropertyValue {
    /**
     * @generated from protobuf field: sushi_rpc.PropertyIdentifier property = 1;
     */
    property?: PropertyIdentifier;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf message sushi_rpc.PropertyIdRequest
 */
export interface PropertyIdRequest {
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorIdentifier processor = 1;
     */
    processor?: ProcessorIdentifier;
    /**
     * @generated from protobuf field: string property_name = 2;
     */
    propertyName: string;
}
/**
 * @generated from protobuf message sushi_rpc.PluginType
 */
export interface PluginType {
    /**
     * @generated from protobuf field: sushi_rpc.PluginType.Type type = 1;
     */
    type: PluginType_Type;
}
/**
 * @generated from protobuf enum sushi_rpc.PluginType.Type
 */
export enum PluginType_Type {
    /**
     * @generated from protobuf enum value: DUMMY = 0;
     */
    DUMMY = 0,
    /**
     * @generated from protobuf enum value: INTERNAL = 1;
     */
    INTERNAL = 1,
    /**
     * @generated from protobuf enum value: VST2X = 2;
     */
    VST2X = 2,
    /**
     * @generated from protobuf enum value: VST3X = 3;
     */
    VST3X = 3,
    /**
     * @generated from protobuf enum value: LV2 = 4;
     */
    LV2 = 4
}
/**
 * @generated from protobuf message sushi_rpc.ProcessorPosition
 */
export interface ProcessorPosition {
    /**
     * @generated from protobuf field: bool add_to_back = 1;
     */
    addToBack: boolean;
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorIdentifier before_processor = 2;
     */
    beforeProcessor?: ProcessorIdentifier;
}
/**
 * @generated from protobuf message sushi_rpc.CreateTrackRequest
 */
export interface CreateTrackRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 channels = 2;
     */
    channels: number;
}
/**
 * @generated from protobuf message sushi_rpc.CreateMultibusTrackRequest
 */
export interface CreateMultibusTrackRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 buses = 2;
     */
    buses: number;
}
/**
 * @generated from protobuf message sushi_rpc.CreatePreTrackRequest
 */
export interface CreatePreTrackRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message sushi_rpc.CreatePostTrackRequest
 */
export interface CreatePostTrackRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message sushi_rpc.CreateProcessorRequest
 */
export interface CreateProcessorRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string uid = 2;
     */
    uid: string;
    /**
     * @generated from protobuf field: string path = 3;
     */
    path: string;
    /**
     * @generated from protobuf field: sushi_rpc.PluginType type = 4;
     */
    type?: PluginType;
    /**
     * @generated from protobuf field: sushi_rpc.TrackIdentifier track = 5;
     */
    track?: TrackIdentifier;
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorPosition position = 6;
     */
    position?: ProcessorPosition;
}
/**
 * @generated from protobuf message sushi_rpc.MoveProcessorRequest
 */
export interface MoveProcessorRequest {
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorIdentifier processor = 1;
     */
    processor?: ProcessorIdentifier;
    /**
     * @generated from protobuf field: sushi_rpc.TrackIdentifier source_track = 2;
     */
    sourceTrack?: TrackIdentifier;
    /**
     * @generated from protobuf field: sushi_rpc.TrackIdentifier dest_track = 3;
     */
    destTrack?: TrackIdentifier;
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorPosition position = 4;
     */
    position?: ProcessorPosition;
}
/**
 * @generated from protobuf message sushi_rpc.DeleteProcessorRequest
 */
export interface DeleteProcessorRequest {
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorIdentifier processor = 1;
     */
    processor?: ProcessorIdentifier;
    /**
     * @generated from protobuf field: sushi_rpc.TrackIdentifier track = 2;
     */
    track?: TrackIdentifier;
}
/**
 * @generated from protobuf message sushi_rpc.ParameterNotificationBlocklist
 */
export interface ParameterNotificationBlocklist {
    /**
     * @generated from protobuf field: repeated sushi_rpc.ParameterIdentifier parameters = 1;
     */
    parameters: ParameterIdentifier[];
}
/**
 * @generated from protobuf message sushi_rpc.PropertyNotificationBlocklist
 */
export interface PropertyNotificationBlocklist {
    /**
     * @generated from protobuf field: repeated sushi_rpc.PropertyIdentifier properties = 1;
     */
    properties: PropertyIdentifier[];
}
/**
 * @generated from protobuf message sushi_rpc.MidiChannel
 */
export interface MidiChannel {
    /**
     * @generated from protobuf field: sushi_rpc.MidiChannel.Channel channel = 1;
     */
    channel: MidiChannel_Channel;
}
/**
 * @generated from protobuf enum sushi_rpc.MidiChannel.Channel
 */
export enum MidiChannel_Channel {
    /**
     * @generated from protobuf enum value: DUMMY = 0;
     */
    DUMMY = 0,
    /**
     * @generated from protobuf enum value: MIDI_CH_1 = 1;
     */
    MIDI_CH_1 = 1,
    /**
     * @generated from protobuf enum value: MIDI_CH_2 = 2;
     */
    MIDI_CH_2 = 2,
    /**
     * @generated from protobuf enum value: MIDI_CH_3 = 3;
     */
    MIDI_CH_3 = 3,
    /**
     * @generated from protobuf enum value: MIDI_CH_4 = 4;
     */
    MIDI_CH_4 = 4,
    /**
     * @generated from protobuf enum value: MIDI_CH_5 = 5;
     */
    MIDI_CH_5 = 5,
    /**
     * @generated from protobuf enum value: MIDI_CH_6 = 6;
     */
    MIDI_CH_6 = 6,
    /**
     * @generated from protobuf enum value: MIDI_CH_7 = 7;
     */
    MIDI_CH_7 = 7,
    /**
     * @generated from protobuf enum value: MIDI_CH_8 = 8;
     */
    MIDI_CH_8 = 8,
    /**
     * @generated from protobuf enum value: MIDI_CH_9 = 9;
     */
    MIDI_CH_9 = 9,
    /**
     * @generated from protobuf enum value: MIDI_CH_10 = 10;
     */
    MIDI_CH_10 = 10,
    /**
     * @generated from protobuf enum value: MIDI_CH_11 = 11;
     */
    MIDI_CH_11 = 11,
    /**
     * @generated from protobuf enum value: MIDI_CH_12 = 12;
     */
    MIDI_CH_12 = 12,
    /**
     * @generated from protobuf enum value: MIDI_CH_13 = 13;
     */
    MIDI_CH_13 = 13,
    /**
     * @generated from protobuf enum value: MIDI_CH_14 = 14;
     */
    MIDI_CH_14 = 14,
    /**
     * @generated from protobuf enum value: MIDI_CH_15 = 15;
     */
    MIDI_CH_15 = 15,
    /**
     * @generated from protobuf enum value: MIDI_CH_16 = 16;
     */
    MIDI_CH_16 = 16,
    /**
     * @generated from protobuf enum value: MIDI_CH_OMNI = 17;
     */
    MIDI_CH_OMNI = 17
}
/**
 * @generated from protobuf message sushi_rpc.AudioConnection
 */
export interface AudioConnection {
    /**
     * @generated from protobuf field: sushi_rpc.TrackIdentifier track = 1;
     */
    track?: TrackIdentifier;
    /**
     * @generated from protobuf field: int32 track_channel = 2;
     */
    trackChannel: number;
    /**
     * @generated from protobuf field: int32 engine_channel = 3;
     */
    engineChannel: number;
}
/**
 * @generated from protobuf message sushi_rpc.AudioConnectionList
 */
export interface AudioConnectionList {
    /**
     * @generated from protobuf field: repeated sushi_rpc.AudioConnection connections = 1;
     */
    connections: AudioConnection[];
}
/**
 * @generated from protobuf message sushi_rpc.CvConnection
 */
export interface CvConnection {
    /**
     * @generated from protobuf field: sushi_rpc.ParameterIdentifier parameter = 1;
     */
    parameter?: ParameterIdentifier;
    /**
     * @generated from protobuf field: int32 cv_port_id = 2;
     */
    cvPortId: number;
}
/**
 * @generated from protobuf message sushi_rpc.CvConnectionList
 */
export interface CvConnectionList {
    /**
     * @generated from protobuf field: repeated sushi_rpc.CvConnection connections = 1;
     */
    connections: CvConnection[];
}
/**
 * @generated from protobuf message sushi_rpc.GateConnection
 */
export interface GateConnection {
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorIdentifier processor = 1;
     */
    processor?: ProcessorIdentifier;
    /**
     * @generated from protobuf field: int32 gate_port_id = 2;
     */
    gatePortId: number;
    /**
     * @generated from protobuf field: int32 channel = 3;
     */
    channel: number;
    /**
     * @generated from protobuf field: int32 note_no = 4;
     */
    noteNo: number;
}
/**
 * @generated from protobuf message sushi_rpc.GateConnectionList
 */
export interface GateConnectionList {
    /**
     * @generated from protobuf field: repeated sushi_rpc.GateConnection connections = 1;
     */
    connections: GateConnection[];
}
/**
 * @generated from protobuf message sushi_rpc.MidiKbdConnection
 */
export interface MidiKbdConnection {
    /**
     * @generated from protobuf field: sushi_rpc.TrackIdentifier track = 1;
     */
    track?: TrackIdentifier;
    /**
     * @generated from protobuf field: sushi_rpc.MidiChannel channel = 2;
     */
    channel?: MidiChannel;
    /**
     * @generated from protobuf field: int32 port = 3;
     */
    port: number;
    /**
     * @generated from protobuf field: bool raw_midi = 7;
     */
    rawMidi: boolean;
}
/**
 * @generated from protobuf message sushi_rpc.MidiKbdConnectionList
 */
export interface MidiKbdConnectionList {
    /**
     * @generated from protobuf field: repeated sushi_rpc.MidiKbdConnection connections = 1;
     */
    connections: MidiKbdConnection[];
}
/**
 * @generated from protobuf message sushi_rpc.MidiCCConnection
 */
export interface MidiCCConnection {
    /**
     * @generated from protobuf field: sushi_rpc.ParameterIdentifier parameter = 1;
     */
    parameter?: ParameterIdentifier;
    /**
     * @generated from protobuf field: sushi_rpc.MidiChannel channel = 2;
     */
    channel?: MidiChannel;
    /**
     * @generated from protobuf field: int32 port = 3;
     */
    port: number;
    /**
     * @generated from protobuf field: int32 cc_number = 4;
     */
    ccNumber: number;
    /**
     * @generated from protobuf field: float min_range = 5;
     */
    minRange: number;
    /**
     * @generated from protobuf field: float max_range = 6;
     */
    maxRange: number;
    /**
     * @generated from protobuf field: bool relative_mode = 7;
     */
    relativeMode: boolean;
}
/**
 * @generated from protobuf message sushi_rpc.MidiCCConnectionList
 */
export interface MidiCCConnectionList {
    /**
     * @generated from protobuf field: repeated sushi_rpc.MidiCCConnection connections = 1;
     */
    connections: MidiCCConnection[];
}
/**
 * @generated from protobuf message sushi_rpc.MidiPCConnection
 */
export interface MidiPCConnection {
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorIdentifier processor = 1;
     */
    processor?: ProcessorIdentifier;
    /**
     * @generated from protobuf field: sushi_rpc.MidiChannel channel = 2;
     */
    channel?: MidiChannel;
    /**
     * @generated from protobuf field: int32 port = 3;
     */
    port: number;
}
/**
 * @generated from protobuf message sushi_rpc.MidiPCConnectionList
 */
export interface MidiPCConnectionList {
    /**
     * @generated from protobuf field: repeated sushi_rpc.MidiPCConnection connections = 1;
     */
    connections: MidiPCConnection[];
}
/**
 * @generated from protobuf message sushi_rpc.MidiClockSetRequest
 */
export interface MidiClockSetRequest {
    /**
     * @generated from protobuf field: int32 port = 1;
     */
    port: number;
    /**
     * @generated from protobuf field: bool enabled = 2;
     */
    enabled: boolean;
}
/**
 * @generated from protobuf message sushi_rpc.OscParameterOutputList
 */
export interface OscParameterOutputList {
    /**
     * @generated from protobuf field: repeated string path = 1;
     */
    path: string[];
}
/**
 * @generated from protobuf message sushi_rpc.TransportUpdate
 */
export interface TransportUpdate {
    /**
     * @generated from protobuf oneof: Transport
     */
    transport: {
        oneofKind: "tempo";
        /**
         * @generated from protobuf field: float tempo = 1;
         */
        tempo: number;
    } | {
        oneofKind: "playingMode";
        /**
         * @generated from protobuf field: sushi_rpc.PlayingMode playing_mode = 2;
         */
        playingMode: PlayingMode;
    } | {
        oneofKind: "syncMode";
        /**
         * @generated from protobuf field: sushi_rpc.SyncMode sync_mode = 3;
         */
        syncMode: SyncMode;
    } | {
        oneofKind: "timeSignature";
        /**
         * @generated from protobuf field: sushi_rpc.TimeSignature time_signature = 4;
         */
        timeSignature: TimeSignature;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message sushi_rpc.TrackUpdate
 */
export interface TrackUpdate {
    /**
     * @generated from protobuf field: sushi_rpc.TrackUpdate.Action action = 1;
     */
    action: TrackUpdate_Action;
    /**
     * @generated from protobuf field: sushi_rpc.TrackIdentifier track = 2;
     */
    track?: TrackIdentifier;
}
/**
 * @generated from protobuf enum sushi_rpc.TrackUpdate.Action
 */
export enum TrackUpdate_Action {
    /**
     * @generated from protobuf enum value: DUMMY = 0;
     */
    DUMMY = 0,
    /**
     * @generated from protobuf enum value: TRACK_ADDED = 1;
     */
    TRACK_ADDED = 1,
    /**
     * @generated from protobuf enum value: TRACK_DELETED = 2;
     */
    TRACK_DELETED = 2
}
/**
 * @generated from protobuf message sushi_rpc.ProcessorUpdate
 */
export interface ProcessorUpdate {
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorUpdate.Action action = 1;
     */
    action: ProcessorUpdate_Action;
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorIdentifier processor = 2;
     */
    processor?: ProcessorIdentifier;
    /**
     * @generated from protobuf field: sushi_rpc.TrackIdentifier parent_track = 3;
     */
    parentTrack?: TrackIdentifier;
}
/**
 * @generated from protobuf enum sushi_rpc.ProcessorUpdate.Action
 */
export enum ProcessorUpdate_Action {
    /**
     * @generated from protobuf enum value: DUMMY = 0;
     */
    DUMMY = 0,
    /**
     * @generated from protobuf enum value: PROCESSOR_ADDED = 1;
     */
    PROCESSOR_ADDED = 1,
    /**
     * @generated from protobuf enum value: PROCESSOR_DELETED = 2;
     */
    PROCESSOR_DELETED = 2
}
/**
 * @generated from protobuf message sushi_rpc.MidiKbdConnectionState
 */
export interface MidiKbdConnectionState {
    /**
     * @generated from protobuf field: string track = 1;
     */
    track: string;
    /**
     * @generated from protobuf field: sushi_rpc.MidiChannel channel = 2;
     */
    channel?: MidiChannel;
    /**
     * @generated from protobuf field: int32 port = 3;
     */
    port: number;
    /**
     * @generated from protobuf field: bool raw_midi = 7;
     */
    rawMidi: boolean;
}
/**
 * @generated from protobuf message sushi_rpc.MidiCCConnectionState
 */
export interface MidiCCConnectionState {
    /**
     * @generated from protobuf field: string processor = 1;
     */
    processor: string;
    /**
     * @generated from protobuf field: sushi_rpc.ParameterIdentifier parameter = 2;
     */
    parameter?: ParameterIdentifier;
    /**
     * @generated from protobuf field: sushi_rpc.MidiChannel channel = 3;
     */
    channel?: MidiChannel;
    /**
     * @generated from protobuf field: int32 port = 4;
     */
    port: number;
    /**
     * @generated from protobuf field: int32 cc_number = 5;
     */
    ccNumber: number;
    /**
     * @generated from protobuf field: float min_range = 6;
     */
    minRange: number;
    /**
     * @generated from protobuf field: float max_range = 7;
     */
    maxRange: number;
    /**
     * @generated from protobuf field: bool relative_mode = 8;
     */
    relativeMode: boolean;
}
/**
 * @generated from protobuf message sushi_rpc.MidiPCConnectionState
 */
export interface MidiPCConnectionState {
    /**
     * @generated from protobuf field: string processor = 1;
     */
    processor: string;
    /**
     * @generated from protobuf field: sushi_rpc.MidiChannel channel = 2;
     */
    channel?: MidiChannel;
    /**
     * @generated from protobuf field: int32 port = 3;
     */
    port: number;
}
/**
 * @generated from protobuf message sushi_rpc.MidiState
 */
export interface MidiState {
    /**
     * @generated from protobuf field: int32 inputs = 1;
     */
    inputs: number;
    /**
     * @generated from protobuf field: int32 outputs = 2;
     */
    outputs: number;
    /**
     * @generated from protobuf field: repeated sushi_rpc.MidiKbdConnectionState kbd_input_connections = 3;
     */
    kbdInputConnections: MidiKbdConnectionState[];
    /**
     * @generated from protobuf field: repeated sushi_rpc.MidiKbdConnectionState kbd_output_connections = 4;
     */
    kbdOutputConnections: MidiKbdConnectionState[];
    /**
     * @generated from protobuf field: repeated sushi_rpc.MidiCCConnectionState cc_connections = 5;
     */
    ccConnections: MidiCCConnectionState[];
    /**
     * @generated from protobuf field: repeated sushi_rpc.MidiPCConnectionState pc_connections = 6;
     */
    pcConnections: MidiPCConnectionState[];
    /**
     * @generated from protobuf field: repeated int32 enabled_clock_outputs = 7;
     */
    enabledClockOutputs: number[];
}
/**
 * @generated from protobuf message sushi_rpc.OscParameterState
 */
export interface OscParameterState {
    /**
     * @generated from protobuf field: string processor = 1;
     */
    processor: string;
    /**
     * @generated from protobuf field: repeated int32 parameter_ids = 2;
     */
    parameterIds: number[];
}
/**
 * @generated from protobuf message sushi_rpc.OscState
 */
export interface OscState {
    /**
     * @generated from protobuf field: bool enable_all_processor_outputs = 1;
     */
    enableAllProcessorOutputs: boolean;
    /**
     * @generated from protobuf field: repeated sushi_rpc.OscParameterState enabled_processor_outputs = 2;
     */
    enabledProcessorOutputs: OscParameterState[];
}
/**
 * @generated from protobuf message sushi_rpc.TrackAudioConnectionState
 */
export interface TrackAudioConnectionState {
    /**
     * @generated from protobuf field: string track = 1;
     */
    track: string;
    /**
     * @generated from protobuf field: int32 track_channel = 2;
     */
    trackChannel: number;
    /**
     * @generated from protobuf field: int32 engine_channel = 3;
     */
    engineChannel: number;
}
/**
 * @generated from protobuf message sushi_rpc.EngineState
 */
export interface EngineState {
    /**
     * @generated from protobuf field: float sample_rate = 1;
     */
    sampleRate: number;
    /**
     * @generated from protobuf field: float tempo = 2;
     */
    tempo: number;
    /**
     * @generated from protobuf field: sushi_rpc.PlayingMode playing_mode = 3;
     */
    playingMode?: PlayingMode;
    /**
     * @generated from protobuf field: sushi_rpc.SyncMode sync_mode = 4;
     */
    syncMode?: SyncMode;
    /**
     * @generated from protobuf field: sushi_rpc.TimeSignature time_signature = 5;
     */
    timeSignature?: TimeSignature;
    /**
     * @generated from protobuf field: bool clip_detection_input = 6;
     */
    clipDetectionInput: boolean;
    /**
     * @generated from protobuf field: bool clip_detection_output = 7;
     */
    clipDetectionOutput: boolean;
    /**
     * @generated from protobuf field: bool master_limiter = 8;
     */
    masterLimiter: boolean;
    /**
     * @generated from protobuf field: int32 used_audio_inputs = 9;
     */
    usedAudioInputs: number;
    /**
     * @generated from protobuf field: int32 used_audio_outputs = 10;
     */
    usedAudioOutputs: number;
    /**
     * @generated from protobuf field: repeated sushi_rpc.TrackAudioConnectionState input_connections = 11;
     */
    inputConnections: TrackAudioConnectionState[];
    /**
     * @generated from protobuf field: repeated sushi_rpc.TrackAudioConnectionState output_connections = 12;
     */
    outputConnections: TrackAudioConnectionState[];
}
/**
 * @generated from protobuf message sushi_rpc.PluginClass
 */
export interface PluginClass {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string label = 2;
     */
    label: string;
    /**
     * @generated from protobuf field: string uid = 3;
     */
    uid: string;
    /**
     * @generated from protobuf field: string path = 4;
     */
    path: string;
    /**
     * @generated from protobuf field: sushi_rpc.PluginType type = 5;
     */
    type?: PluginType;
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorState state = 6;
     */
    state?: ProcessorState;
}
/**
 * @generated from protobuf message sushi_rpc.TrackState
 */
export interface TrackState {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string label = 2;
     */
    label: string;
    /**
     * @generated from protobuf field: int32 channels = 3;
     */
    channels: number;
    /**
     * @generated from protobuf field: int32 buses = 4;
     */
    buses: number;
    /**
     * @generated from protobuf field: sushi_rpc.TrackType type = 5;
     */
    type?: TrackType;
    /**
     * @generated from protobuf field: sushi_rpc.ProcessorState track_state = 6;
     */
    trackState?: ProcessorState;
    /**
     * @generated from protobuf field: repeated sushi_rpc.PluginClass processors = 7;
     */
    processors: PluginClass[];
}
/**
 * @generated from protobuf message sushi_rpc.SessionState
 */
export interface SessionState {
    /**
     * @generated from protobuf field: sushi_rpc.SushiBuildInfo sushi_info = 1;
     */
    sushiInfo?: SushiBuildInfo;
    /**
     * @generated from protobuf field: string save_date = 2;
     */
    saveDate: string;
    /**
     * @generated from protobuf field: sushi_rpc.OscState osc_state = 3;
     */
    oscState?: OscState;
    /**
     * @generated from protobuf field: sushi_rpc.MidiState midi_state = 4;
     */
    midiState?: MidiState;
    /**
     * @generated from protobuf field: sushi_rpc.EngineState engine_state = 5;
     */
    engineState?: EngineState;
    /**
     * @generated from protobuf field: repeated sushi_rpc.TrackState tracks = 6;
     */
    tracks: TrackState[];
}
// @generated message type with reflection information, may provide speed optimized methods
class GenericVoidValue$Type extends MessageType<GenericVoidValue> {
    constructor() {
        super("sushi_rpc.GenericVoidValue", []);
    }
    create(value?: PartialMessage<GenericVoidValue>): GenericVoidValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GenericVoidValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenericVoidValue): GenericVoidValue {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GenericVoidValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.GenericVoidValue
 */
export const GenericVoidValue = new GenericVoidValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenericFloatValue$Type extends MessageType<GenericFloatValue> {
    constructor() {
        super("sushi_rpc.GenericFloatValue", [
            { no: 1, name: "value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<GenericFloatValue>): GenericFloatValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<GenericFloatValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenericFloatValue): GenericFloatValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float value */ 1:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenericFloatValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float value = 1; */
        if (message.value !== 0)
            writer.tag(1, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.GenericFloatValue
 */
export const GenericFloatValue = new GenericFloatValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenericIntValue$Type extends MessageType<GenericIntValue> {
    constructor() {
        super("sushi_rpc.GenericIntValue", [
            { no: 1, name: "value", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GenericIntValue>): GenericIntValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<GenericIntValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenericIntValue): GenericIntValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 value */ 1:
                    message.value = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenericIntValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 value = 1; */
        if (message.value !== 0)
            writer.tag(1, WireType.Varint).int32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.GenericIntValue
 */
export const GenericIntValue = new GenericIntValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenericBoolValue$Type extends MessageType<GenericBoolValue> {
    constructor() {
        super("sushi_rpc.GenericBoolValue", [
            { no: 1, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GenericBoolValue>): GenericBoolValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = false;
        if (value !== undefined)
            reflectionMergePartial<GenericBoolValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenericBoolValue): GenericBoolValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool value */ 1:
                    message.value = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenericBoolValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool value = 1; */
        if (message.value !== false)
            writer.tag(1, WireType.Varint).bool(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.GenericBoolValue
 */
export const GenericBoolValue = new GenericBoolValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenericStringValue$Type extends MessageType<GenericStringValue> {
    constructor() {
        super("sushi_rpc.GenericStringValue", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GenericStringValue>): GenericStringValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<GenericStringValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenericStringValue): GenericStringValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenericStringValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.GenericStringValue
 */
export const GenericStringValue = new GenericStringValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OptionalBoolValue$Type extends MessageType<OptionalBoolValue> {
    constructor() {
        super("sushi_rpc.OptionalBoolValue", [
            { no: 1, name: "has_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<OptionalBoolValue>): OptionalBoolValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hasValue = false;
        message.value = false;
        if (value !== undefined)
            reflectionMergePartial<OptionalBoolValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OptionalBoolValue): OptionalBoolValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool has_value */ 1:
                    message.hasValue = reader.bool();
                    break;
                case /* bool value */ 2:
                    message.value = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OptionalBoolValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool has_value = 1; */
        if (message.hasValue !== false)
            writer.tag(1, WireType.Varint).bool(message.hasValue);
        /* bool value = 2; */
        if (message.value !== false)
            writer.tag(2, WireType.Varint).bool(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.OptionalBoolValue
 */
export const OptionalBoolValue = new OptionalBoolValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OptionalIntValue$Type extends MessageType<OptionalIntValue> {
    constructor() {
        super("sushi_rpc.OptionalIntValue", [
            { no: 1, name: "has_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "value", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<OptionalIntValue>): OptionalIntValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hasValue = false;
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<OptionalIntValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OptionalIntValue): OptionalIntValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool has_value */ 1:
                    message.hasValue = reader.bool();
                    break;
                case /* int32 value */ 2:
                    message.value = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OptionalIntValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool has_value = 1; */
        if (message.hasValue !== false)
            writer.tag(1, WireType.Varint).bool(message.hasValue);
        /* int32 value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Varint).int32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.OptionalIntValue
 */
export const OptionalIntValue = new OptionalIntValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SushiBuildInfo$Type extends MessageType<SushiBuildInfo> {
    constructor() {
        super("sushi_rpc.SushiBuildInfo", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "build_options", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "audio_buffer_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "commit_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "build_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SushiBuildInfo>): SushiBuildInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.buildOptions = [];
        message.audioBufferSize = 0;
        message.commitHash = "";
        message.buildDate = "";
        if (value !== undefined)
            reflectionMergePartial<SushiBuildInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SushiBuildInfo): SushiBuildInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* repeated string build_options */ 2:
                    message.buildOptions.push(reader.string());
                    break;
                case /* int32 audio_buffer_size */ 3:
                    message.audioBufferSize = reader.int32();
                    break;
                case /* string commit_hash */ 4:
                    message.commitHash = reader.string();
                    break;
                case /* string build_date */ 5:
                    message.buildDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SushiBuildInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* repeated string build_options = 2; */
        for (let i = 0; i < message.buildOptions.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.buildOptions[i]);
        /* int32 audio_buffer_size = 3; */
        if (message.audioBufferSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.audioBufferSize);
        /* string commit_hash = 4; */
        if (message.commitHash !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.commitHash);
        /* string build_date = 5; */
        if (message.buildDate !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.buildDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.SushiBuildInfo
 */
export const SushiBuildInfo = new SushiBuildInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackIdentifier$Type extends MessageType<TrackIdentifier> {
    constructor() {
        super("sushi_rpc.TrackIdentifier", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TrackIdentifier>): TrackIdentifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<TrackIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackIdentifier): TrackIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.TrackIdentifier
 */
export const TrackIdentifier = new TrackIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessorIdentifier$Type extends MessageType<ProcessorIdentifier> {
    constructor() {
        super("sushi_rpc.ProcessorIdentifier", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProcessorIdentifier>): ProcessorIdentifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<ProcessorIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessorIdentifier): ProcessorIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessorIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ProcessorIdentifier
 */
export const ProcessorIdentifier = new ProcessorIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParameterIdentifier$Type extends MessageType<ParameterIdentifier> {
    constructor() {
        super("sushi_rpc.ParameterIdentifier", [
            { no: 1, name: "processor_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "parameter_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ParameterIdentifier>): ParameterIdentifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.processorId = 0;
        message.parameterId = 0;
        if (value !== undefined)
            reflectionMergePartial<ParameterIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParameterIdentifier): ParameterIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 processor_id */ 1:
                    message.processorId = reader.int32();
                    break;
                case /* int32 parameter_id */ 2:
                    message.parameterId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParameterIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 processor_id = 1; */
        if (message.processorId !== 0)
            writer.tag(1, WireType.Varint).int32(message.processorId);
        /* int32 parameter_id = 2; */
        if (message.parameterId !== 0)
            writer.tag(2, WireType.Varint).int32(message.parameterId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ParameterIdentifier
 */
export const ParameterIdentifier = new ParameterIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropertyIdentifier$Type extends MessageType<PropertyIdentifier> {
    constructor() {
        super("sushi_rpc.PropertyIdentifier", [
            { no: 1, name: "processor_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "property_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PropertyIdentifier>): PropertyIdentifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.processorId = 0;
        message.propertyId = 0;
        if (value !== undefined)
            reflectionMergePartial<PropertyIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PropertyIdentifier): PropertyIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 processor_id */ 1:
                    message.processorId = reader.int32();
                    break;
                case /* int32 property_id */ 2:
                    message.propertyId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PropertyIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 processor_id = 1; */
        if (message.processorId !== 0)
            writer.tag(1, WireType.Varint).int32(message.processorId);
        /* int32 property_id = 2; */
        if (message.propertyId !== 0)
            writer.tag(2, WireType.Varint).int32(message.propertyId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.PropertyIdentifier
 */
export const PropertyIdentifier = new PropertyIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParameterType$Type extends MessageType<ParameterType> {
    constructor() {
        super("sushi_rpc.ParameterType", [
            { no: 1, name: "type", kind: "enum", T: () => ["sushi_rpc.ParameterType.Type", ParameterType_Type] }
        ]);
    }
    create(value?: PartialMessage<ParameterType>): ParameterType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<ParameterType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParameterType): ParameterType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ParameterType.Type type */ 1:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParameterType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ParameterType.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ParameterType
 */
export const ParameterType = new ParameterType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayingMode$Type extends MessageType<PlayingMode> {
    constructor() {
        super("sushi_rpc.PlayingMode", [
            { no: 1, name: "mode", kind: "enum", T: () => ["sushi_rpc.PlayingMode.Mode", PlayingMode_Mode] }
        ]);
    }
    create(value?: PartialMessage<PlayingMode>): PlayingMode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mode = 0;
        if (value !== undefined)
            reflectionMergePartial<PlayingMode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayingMode): PlayingMode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.PlayingMode.Mode mode */ 1:
                    message.mode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayingMode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.PlayingMode.Mode mode = 1; */
        if (message.mode !== 0)
            writer.tag(1, WireType.Varint).int32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.PlayingMode
 */
export const PlayingMode = new PlayingMode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncMode$Type extends MessageType<SyncMode> {
    constructor() {
        super("sushi_rpc.SyncMode", [
            { no: 1, name: "mode", kind: "enum", T: () => ["sushi_rpc.SyncMode.Mode", SyncMode_Mode] }
        ]);
    }
    create(value?: PartialMessage<SyncMode>): SyncMode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mode = 0;
        if (value !== undefined)
            reflectionMergePartial<SyncMode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncMode): SyncMode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.SyncMode.Mode mode */ 1:
                    message.mode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncMode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.SyncMode.Mode mode = 1; */
        if (message.mode !== 0)
            writer.tag(1, WireType.Varint).int32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.SyncMode
 */
export const SyncMode = new SyncMode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeSignature$Type extends MessageType<TimeSignature> {
    constructor() {
        super("sushi_rpc.TimeSignature", [
            { no: 1, name: "numerator", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "denominator", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TimeSignature>): TimeSignature {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.numerator = 0;
        message.denominator = 0;
        if (value !== undefined)
            reflectionMergePartial<TimeSignature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimeSignature): TimeSignature {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 numerator */ 1:
                    message.numerator = reader.int32();
                    break;
                case /* int32 denominator */ 2:
                    message.denominator = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimeSignature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 numerator = 1; */
        if (message.numerator !== 0)
            writer.tag(1, WireType.Varint).int32(message.numerator);
        /* int32 denominator = 2; */
        if (message.denominator !== 0)
            writer.tag(2, WireType.Varint).int32(message.denominator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.TimeSignature
 */
export const TimeSignature = new TimeSignature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CpuTimings$Type extends MessageType<CpuTimings> {
    constructor() {
        super("sushi_rpc.CpuTimings", [
            { no: 1, name: "average", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "min", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "max", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CpuTimings>): CpuTimings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.average = 0;
        message.min = 0;
        message.max = 0;
        if (value !== undefined)
            reflectionMergePartial<CpuTimings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CpuTimings): CpuTimings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float average */ 1:
                    message.average = reader.float();
                    break;
                case /* float min */ 2:
                    message.min = reader.float();
                    break;
                case /* float max */ 3:
                    message.max = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CpuTimings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float average = 1; */
        if (message.average !== 0)
            writer.tag(1, WireType.Bit32).float(message.average);
        /* float min = 2; */
        if (message.min !== 0)
            writer.tag(2, WireType.Bit32).float(message.min);
        /* float max = 3; */
        if (message.max !== 0)
            writer.tag(3, WireType.Bit32).float(message.max);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.CpuTimings
 */
export const CpuTimings = new CpuTimings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NoteOnRequest$Type extends MessageType<NoteOnRequest> {
    constructor() {
        super("sushi_rpc.NoteOnRequest", [
            { no: 1, name: "track", kind: "message", T: () => TrackIdentifier },
            { no: 2, name: "channel", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "note", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "velocity", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<NoteOnRequest>): NoteOnRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.channel = 0;
        message.note = 0;
        message.velocity = 0;
        if (value !== undefined)
            reflectionMergePartial<NoteOnRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NoteOnRequest): NoteOnRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.TrackIdentifier track */ 1:
                    message.track = TrackIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.track);
                    break;
                case /* int32 channel */ 2:
                    message.channel = reader.int32();
                    break;
                case /* int32 note */ 3:
                    message.note = reader.int32();
                    break;
                case /* float velocity */ 4:
                    message.velocity = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NoteOnRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.TrackIdentifier track = 1; */
        if (message.track)
            TrackIdentifier.internalBinaryWrite(message.track, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 channel = 2; */
        if (message.channel !== 0)
            writer.tag(2, WireType.Varint).int32(message.channel);
        /* int32 note = 3; */
        if (message.note !== 0)
            writer.tag(3, WireType.Varint).int32(message.note);
        /* float velocity = 4; */
        if (message.velocity !== 0)
            writer.tag(4, WireType.Bit32).float(message.velocity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.NoteOnRequest
 */
export const NoteOnRequest = new NoteOnRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NoteOffRequest$Type extends MessageType<NoteOffRequest> {
    constructor() {
        super("sushi_rpc.NoteOffRequest", [
            { no: 1, name: "track", kind: "message", T: () => TrackIdentifier },
            { no: 2, name: "channel", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "note", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "velocity", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<NoteOffRequest>): NoteOffRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.channel = 0;
        message.note = 0;
        message.velocity = 0;
        if (value !== undefined)
            reflectionMergePartial<NoteOffRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NoteOffRequest): NoteOffRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.TrackIdentifier track */ 1:
                    message.track = TrackIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.track);
                    break;
                case /* int32 channel */ 2:
                    message.channel = reader.int32();
                    break;
                case /* int32 note */ 3:
                    message.note = reader.int32();
                    break;
                case /* float velocity */ 4:
                    message.velocity = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NoteOffRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.TrackIdentifier track = 1; */
        if (message.track)
            TrackIdentifier.internalBinaryWrite(message.track, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 channel = 2; */
        if (message.channel !== 0)
            writer.tag(2, WireType.Varint).int32(message.channel);
        /* int32 note = 3; */
        if (message.note !== 0)
            writer.tag(3, WireType.Varint).int32(message.note);
        /* float velocity = 4; */
        if (message.velocity !== 0)
            writer.tag(4, WireType.Bit32).float(message.velocity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.NoteOffRequest
 */
export const NoteOffRequest = new NoteOffRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NoteAftertouchRequest$Type extends MessageType<NoteAftertouchRequest> {
    constructor() {
        super("sushi_rpc.NoteAftertouchRequest", [
            { no: 1, name: "track", kind: "message", T: () => TrackIdentifier },
            { no: 2, name: "channel", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "note", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<NoteAftertouchRequest>): NoteAftertouchRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.channel = 0;
        message.note = 0;
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<NoteAftertouchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NoteAftertouchRequest): NoteAftertouchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.TrackIdentifier track */ 1:
                    message.track = TrackIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.track);
                    break;
                case /* int32 channel */ 2:
                    message.channel = reader.int32();
                    break;
                case /* int32 note */ 3:
                    message.note = reader.int32();
                    break;
                case /* float value */ 4:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NoteAftertouchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.TrackIdentifier track = 1; */
        if (message.track)
            TrackIdentifier.internalBinaryWrite(message.track, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 channel = 2; */
        if (message.channel !== 0)
            writer.tag(2, WireType.Varint).int32(message.channel);
        /* int32 note = 3; */
        if (message.note !== 0)
            writer.tag(3, WireType.Varint).int32(message.note);
        /* float value = 4; */
        if (message.value !== 0)
            writer.tag(4, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.NoteAftertouchRequest
 */
export const NoteAftertouchRequest = new NoteAftertouchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NoteModulationRequest$Type extends MessageType<NoteModulationRequest> {
    constructor() {
        super("sushi_rpc.NoteModulationRequest", [
            { no: 1, name: "track", kind: "message", T: () => TrackIdentifier },
            { no: 2, name: "channel", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<NoteModulationRequest>): NoteModulationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.channel = 0;
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<NoteModulationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NoteModulationRequest): NoteModulationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.TrackIdentifier track */ 1:
                    message.track = TrackIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.track);
                    break;
                case /* int32 channel */ 2:
                    message.channel = reader.int32();
                    break;
                case /* float value */ 3:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NoteModulationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.TrackIdentifier track = 1; */
        if (message.track)
            TrackIdentifier.internalBinaryWrite(message.track, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 channel = 2; */
        if (message.channel !== 0)
            writer.tag(2, WireType.Varint).int32(message.channel);
        /* float value = 3; */
        if (message.value !== 0)
            writer.tag(3, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.NoteModulationRequest
 */
export const NoteModulationRequest = new NoteModulationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackType$Type extends MessageType<TrackType> {
    constructor() {
        super("sushi_rpc.TrackType", [
            { no: 1, name: "type", kind: "enum", T: () => ["sushi_rpc.TrackType.Type", TrackType_Type] }
        ]);
    }
    create(value?: PartialMessage<TrackType>): TrackType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<TrackType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackType): TrackType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.TrackType.Type type */ 1:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.TrackType.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.TrackType
 */
export const TrackType = new TrackType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackInfo$Type extends MessageType<TrackInfo> {
    constructor() {
        super("sushi_rpc.TrackInfo", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "channels", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "buses", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "type", kind: "message", T: () => TrackType },
            { no: 7, name: "processors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ProcessorIdentifier }
        ]);
    }
    create(value?: PartialMessage<TrackInfo>): TrackInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.label = "";
        message.name = "";
        message.channels = 0;
        message.buses = 0;
        message.processors = [];
        if (value !== undefined)
            reflectionMergePartial<TrackInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackInfo): TrackInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* int32 channels */ 4:
                    message.channels = reader.int32();
                    break;
                case /* int32 buses */ 5:
                    message.buses = reader.int32();
                    break;
                case /* sushi_rpc.TrackType type */ 6:
                    message.type = TrackType.internalBinaryRead(reader, reader.uint32(), options, message.type);
                    break;
                case /* repeated sushi_rpc.ProcessorIdentifier processors */ 7:
                    message.processors.push(ProcessorIdentifier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* int32 channels = 4; */
        if (message.channels !== 0)
            writer.tag(4, WireType.Varint).int32(message.channels);
        /* int32 buses = 5; */
        if (message.buses !== 0)
            writer.tag(5, WireType.Varint).int32(message.buses);
        /* sushi_rpc.TrackType type = 6; */
        if (message.type)
            TrackType.internalBinaryWrite(message.type, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated sushi_rpc.ProcessorIdentifier processors = 7; */
        for (let i = 0; i < message.processors.length; i++)
            ProcessorIdentifier.internalBinaryWrite(message.processors[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.TrackInfo
 */
export const TrackInfo = new TrackInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackInfoList$Type extends MessageType<TrackInfoList> {
    constructor() {
        super("sushi_rpc.TrackInfoList", [
            { no: 1, name: "tracks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TrackInfo }
        ]);
    }
    create(value?: PartialMessage<TrackInfoList>): TrackInfoList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tracks = [];
        if (value !== undefined)
            reflectionMergePartial<TrackInfoList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackInfoList): TrackInfoList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sushi_rpc.TrackInfo tracks */ 1:
                    message.tracks.push(TrackInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackInfoList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sushi_rpc.TrackInfo tracks = 1; */
        for (let i = 0; i < message.tracks.length; i++)
            TrackInfo.internalBinaryWrite(message.tracks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.TrackInfoList
 */
export const TrackInfoList = new TrackInfoList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessorInfo$Type extends MessageType<ProcessorInfo> {
    constructor() {
        super("sushi_rpc.ProcessorInfo", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "parameter_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "program_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProcessorInfo>): ProcessorInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.label = "";
        message.name = "";
        message.parameterCount = 0;
        message.programCount = 0;
        if (value !== undefined)
            reflectionMergePartial<ProcessorInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessorInfo): ProcessorInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* int32 parameter_count */ 4:
                    message.parameterCount = reader.int32();
                    break;
                case /* int32 program_count */ 5:
                    message.programCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessorInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* int32 parameter_count = 4; */
        if (message.parameterCount !== 0)
            writer.tag(4, WireType.Varint).int32(message.parameterCount);
        /* int32 program_count = 5; */
        if (message.programCount !== 0)
            writer.tag(5, WireType.Varint).int32(message.programCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ProcessorInfo
 */
export const ProcessorInfo = new ProcessorInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessorInfoList$Type extends MessageType<ProcessorInfoList> {
    constructor() {
        super("sushi_rpc.ProcessorInfoList", [
            { no: 1, name: "processors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ProcessorInfo }
        ]);
    }
    create(value?: PartialMessage<ProcessorInfoList>): ProcessorInfoList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.processors = [];
        if (value !== undefined)
            reflectionMergePartial<ProcessorInfoList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessorInfoList): ProcessorInfoList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sushi_rpc.ProcessorInfo processors */ 1:
                    message.processors.push(ProcessorInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessorInfoList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sushi_rpc.ProcessorInfo processors = 1; */
        for (let i = 0; i < message.processors.length; i++)
            ProcessorInfo.internalBinaryWrite(message.processors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ProcessorInfoList
 */
export const ProcessorInfoList = new ProcessorInfoList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProgramIdentifier$Type extends MessageType<ProgramIdentifier> {
    constructor() {
        super("sushi_rpc.ProgramIdentifier", [
            { no: 1, name: "program", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProgramIdentifier>): ProgramIdentifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.program = 0;
        if (value !== undefined)
            reflectionMergePartial<ProgramIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProgramIdentifier): ProgramIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 program */ 1:
                    message.program = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProgramIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 program = 1; */
        if (message.program !== 0)
            writer.tag(1, WireType.Varint).int32(message.program);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ProgramIdentifier
 */
export const ProgramIdentifier = new ProgramIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessorProgramIdentifier$Type extends MessageType<ProcessorProgramIdentifier> {
    constructor() {
        super("sushi_rpc.ProcessorProgramIdentifier", [
            { no: 1, name: "processor", kind: "message", T: () => ProcessorIdentifier },
            { no: 2, name: "program", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProcessorProgramIdentifier>): ProcessorProgramIdentifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.program = 0;
        if (value !== undefined)
            reflectionMergePartial<ProcessorProgramIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessorProgramIdentifier): ProcessorProgramIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ProcessorIdentifier processor */ 1:
                    message.processor = ProcessorIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.processor);
                    break;
                case /* int32 program */ 2:
                    message.program = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessorProgramIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ProcessorIdentifier processor = 1; */
        if (message.processor)
            ProcessorIdentifier.internalBinaryWrite(message.processor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 program = 2; */
        if (message.program !== 0)
            writer.tag(2, WireType.Varint).int32(message.program);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ProcessorProgramIdentifier
 */
export const ProcessorProgramIdentifier = new ProcessorProgramIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProgramInfo$Type extends MessageType<ProgramInfo> {
    constructor() {
        super("sushi_rpc.ProgramInfo", [
            { no: 1, name: "id", kind: "message", T: () => ProgramIdentifier },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ProgramInfo>): ProgramInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ProgramInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProgramInfo): ProgramInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ProgramIdentifier id */ 1:
                    message.id = ProgramIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProgramInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ProgramIdentifier id = 1; */
        if (message.id)
            ProgramIdentifier.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ProgramInfo
 */
export const ProgramInfo = new ProgramInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProgramInfoList$Type extends MessageType<ProgramInfoList> {
    constructor() {
        super("sushi_rpc.ProgramInfoList", [
            { no: 1, name: "programs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ProgramInfo }
        ]);
    }
    create(value?: PartialMessage<ProgramInfoList>): ProgramInfoList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.programs = [];
        if (value !== undefined)
            reflectionMergePartial<ProgramInfoList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProgramInfoList): ProgramInfoList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sushi_rpc.ProgramInfo programs */ 1:
                    message.programs.push(ProgramInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProgramInfoList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sushi_rpc.ProgramInfo programs = 1; */
        for (let i = 0; i < message.programs.length; i++)
            ProgramInfo.internalBinaryWrite(message.programs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ProgramInfoList
 */
export const ProgramInfoList = new ProgramInfoList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessorProgramSetRequest$Type extends MessageType<ProcessorProgramSetRequest> {
    constructor() {
        super("sushi_rpc.ProcessorProgramSetRequest", [
            { no: 1, name: "processor", kind: "message", T: () => ProcessorIdentifier },
            { no: 2, name: "program", kind: "message", T: () => ProgramIdentifier }
        ]);
    }
    create(value?: PartialMessage<ProcessorProgramSetRequest>): ProcessorProgramSetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ProcessorProgramSetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessorProgramSetRequest): ProcessorProgramSetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ProcessorIdentifier processor */ 1:
                    message.processor = ProcessorIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.processor);
                    break;
                case /* sushi_rpc.ProgramIdentifier program */ 2:
                    message.program = ProgramIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.program);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessorProgramSetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ProcessorIdentifier processor = 1; */
        if (message.processor)
            ProcessorIdentifier.internalBinaryWrite(message.processor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.ProgramIdentifier program = 2; */
        if (message.program)
            ProgramIdentifier.internalBinaryWrite(message.program, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ProcessorProgramSetRequest
 */
export const ProcessorProgramSetRequest = new ProcessorProgramSetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessorBypassStateSetRequest$Type extends MessageType<ProcessorBypassStateSetRequest> {
    constructor() {
        super("sushi_rpc.ProcessorBypassStateSetRequest", [
            { no: 1, name: "processor", kind: "message", T: () => ProcessorIdentifier },
            { no: 2, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ProcessorBypassStateSetRequest>): ProcessorBypassStateSetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = false;
        if (value !== undefined)
            reflectionMergePartial<ProcessorBypassStateSetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessorBypassStateSetRequest): ProcessorBypassStateSetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ProcessorIdentifier processor */ 1:
                    message.processor = ProcessorIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.processor);
                    break;
                case /* bool value */ 2:
                    message.value = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessorBypassStateSetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ProcessorIdentifier processor = 1; */
        if (message.processor)
            ProcessorIdentifier.internalBinaryWrite(message.processor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool value = 2; */
        if (message.value !== false)
            writer.tag(2, WireType.Varint).bool(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ProcessorBypassStateSetRequest
 */
export const ProcessorBypassStateSetRequest = new ProcessorBypassStateSetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessorState$Type extends MessageType<ProcessorState> {
    constructor() {
        super("sushi_rpc.ProcessorState", [
            { no: 1, name: "program_id", kind: "message", T: () => OptionalIntValue },
            { no: 2, name: "bypassed", kind: "message", T: () => OptionalBoolValue },
            { no: 3, name: "properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PropertyValue },
            { no: 4, name: "parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ParameterValue },
            { no: 5, name: "binary_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ProcessorState>): ProcessorState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.properties = [];
        message.parameters = [];
        message.binaryData = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ProcessorState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessorState): ProcessorState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.OptionalIntValue program_id */ 1:
                    message.programId = OptionalIntValue.internalBinaryRead(reader, reader.uint32(), options, message.programId);
                    break;
                case /* sushi_rpc.OptionalBoolValue bypassed */ 2:
                    message.bypassed = OptionalBoolValue.internalBinaryRead(reader, reader.uint32(), options, message.bypassed);
                    break;
                case /* repeated sushi_rpc.PropertyValue properties */ 3:
                    message.properties.push(PropertyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated sushi_rpc.ParameterValue parameters */ 4:
                    message.parameters.push(ParameterValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes binary_data */ 5:
                    message.binaryData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessorState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.OptionalIntValue program_id = 1; */
        if (message.programId)
            OptionalIntValue.internalBinaryWrite(message.programId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.OptionalBoolValue bypassed = 2; */
        if (message.bypassed)
            OptionalBoolValue.internalBinaryWrite(message.bypassed, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated sushi_rpc.PropertyValue properties = 3; */
        for (let i = 0; i < message.properties.length; i++)
            PropertyValue.internalBinaryWrite(message.properties[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated sushi_rpc.ParameterValue parameters = 4; */
        for (let i = 0; i < message.parameters.length; i++)
            ParameterValue.internalBinaryWrite(message.parameters[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bytes binary_data = 5; */
        if (message.binaryData.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.binaryData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ProcessorState
 */
export const ProcessorState = new ProcessorState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessorStateSetRequest$Type extends MessageType<ProcessorStateSetRequest> {
    constructor() {
        super("sushi_rpc.ProcessorStateSetRequest", [
            { no: 1, name: "processor", kind: "message", T: () => ProcessorIdentifier },
            { no: 2, name: "state", kind: "message", T: () => ProcessorState }
        ]);
    }
    create(value?: PartialMessage<ProcessorStateSetRequest>): ProcessorStateSetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ProcessorStateSetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessorStateSetRequest): ProcessorStateSetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ProcessorIdentifier processor */ 1:
                    message.processor = ProcessorIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.processor);
                    break;
                case /* sushi_rpc.ProcessorState state */ 2:
                    message.state = ProcessorState.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessorStateSetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ProcessorIdentifier processor = 1; */
        if (message.processor)
            ProcessorIdentifier.internalBinaryWrite(message.processor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.ProcessorState state = 2; */
        if (message.state)
            ProcessorState.internalBinaryWrite(message.state, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ProcessorStateSetRequest
 */
export const ProcessorStateSetRequest = new ProcessorStateSetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParameterInfo$Type extends MessageType<ParameterInfo> {
    constructor() {
        super("sushi_rpc.ParameterInfo", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "message", T: () => ParameterType },
            { no: 3, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "unit", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "automatable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "min_domain_value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "max_domain_value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ParameterInfo>): ParameterInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.label = "";
        message.name = "";
        message.unit = "";
        message.automatable = false;
        message.minDomainValue = 0;
        message.maxDomainValue = 0;
        if (value !== undefined)
            reflectionMergePartial<ParameterInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParameterInfo): ParameterInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* sushi_rpc.ParameterType type */ 2:
                    message.type = ParameterType.internalBinaryRead(reader, reader.uint32(), options, message.type);
                    break;
                case /* string label */ 3:
                    message.label = reader.string();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* string unit */ 5:
                    message.unit = reader.string();
                    break;
                case /* bool automatable */ 6:
                    message.automatable = reader.bool();
                    break;
                case /* float min_domain_value */ 7:
                    message.minDomainValue = reader.float();
                    break;
                case /* float max_domain_value */ 8:
                    message.maxDomainValue = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParameterInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* sushi_rpc.ParameterType type = 2; */
        if (message.type)
            ParameterType.internalBinaryWrite(message.type, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string label = 3; */
        if (message.label !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.label);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* string unit = 5; */
        if (message.unit !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.unit);
        /* bool automatable = 6; */
        if (message.automatable !== false)
            writer.tag(6, WireType.Varint).bool(message.automatable);
        /* float min_domain_value = 7; */
        if (message.minDomainValue !== 0)
            writer.tag(7, WireType.Bit32).float(message.minDomainValue);
        /* float max_domain_value = 8; */
        if (message.maxDomainValue !== 0)
            writer.tag(8, WireType.Bit32).float(message.maxDomainValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ParameterInfo
 */
export const ParameterInfo = new ParameterInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParameterInfoList$Type extends MessageType<ParameterInfoList> {
    constructor() {
        super("sushi_rpc.ParameterInfoList", [
            { no: 1, name: "parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ParameterInfo }
        ]);
    }
    create(value?: PartialMessage<ParameterInfoList>): ParameterInfoList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parameters = [];
        if (value !== undefined)
            reflectionMergePartial<ParameterInfoList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParameterInfoList): ParameterInfoList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sushi_rpc.ParameterInfo parameters */ 1:
                    message.parameters.push(ParameterInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParameterInfoList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sushi_rpc.ParameterInfo parameters = 1; */
        for (let i = 0; i < message.parameters.length; i++)
            ParameterInfo.internalBinaryWrite(message.parameters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ParameterInfoList
 */
export const ParameterInfoList = new ParameterInfoList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParameterIdRequest$Type extends MessageType<ParameterIdRequest> {
    constructor() {
        super("sushi_rpc.ParameterIdRequest", [
            { no: 1, name: "processor", kind: "message", T: () => ProcessorIdentifier },
            { no: 2, name: "ParameterName", kind: "scalar", jsonName: "ParameterName", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ParameterIdRequest>): ParameterIdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parameterName = "";
        if (value !== undefined)
            reflectionMergePartial<ParameterIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParameterIdRequest): ParameterIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ProcessorIdentifier processor */ 1:
                    message.processor = ProcessorIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.processor);
                    break;
                case /* string ParameterName = 2 [json_name = "ParameterName"];*/ 2:
                    message.parameterName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParameterIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ProcessorIdentifier processor = 1; */
        if (message.processor)
            ProcessorIdentifier.internalBinaryWrite(message.processor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string ParameterName = 2 [json_name = "ParameterName"]; */
        if (message.parameterName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.parameterName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ParameterIdRequest
 */
export const ParameterIdRequest = new ParameterIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParameterValue$Type extends MessageType<ParameterValue> {
    constructor() {
        super("sushi_rpc.ParameterValue", [
            { no: 1, name: "parameter", kind: "message", T: () => ParameterIdentifier },
            { no: 2, name: "value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ParameterValue>): ParameterValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<ParameterValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParameterValue): ParameterValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ParameterIdentifier parameter */ 1:
                    message.parameter = ParameterIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.parameter);
                    break;
                case /* float value */ 2:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParameterValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ParameterIdentifier parameter = 1; */
        if (message.parameter)
            ParameterIdentifier.internalBinaryWrite(message.parameter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* float value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ParameterValue
 */
export const ParameterValue = new ParameterValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParameterUpdate$Type extends MessageType<ParameterUpdate> {
    constructor() {
        super("sushi_rpc.ParameterUpdate", [
            { no: 1, name: "parameter", kind: "message", T: () => ParameterIdentifier },
            { no: 2, name: "normalized_value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "domain_value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "formatted_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ParameterUpdate>): ParameterUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.normalizedValue = 0;
        message.domainValue = 0;
        message.formattedValue = "";
        if (value !== undefined)
            reflectionMergePartial<ParameterUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParameterUpdate): ParameterUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ParameterIdentifier parameter */ 1:
                    message.parameter = ParameterIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.parameter);
                    break;
                case /* float normalized_value */ 2:
                    message.normalizedValue = reader.float();
                    break;
                case /* float domain_value */ 3:
                    message.domainValue = reader.float();
                    break;
                case /* string formatted_value */ 4:
                    message.formattedValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParameterUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ParameterIdentifier parameter = 1; */
        if (message.parameter)
            ParameterIdentifier.internalBinaryWrite(message.parameter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* float normalized_value = 2; */
        if (message.normalizedValue !== 0)
            writer.tag(2, WireType.Bit32).float(message.normalizedValue);
        /* float domain_value = 3; */
        if (message.domainValue !== 0)
            writer.tag(3, WireType.Bit32).float(message.domainValue);
        /* string formatted_value = 4; */
        if (message.formattedValue !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.formattedValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ParameterUpdate
 */
export const ParameterUpdate = new ParameterUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropertyInfo$Type extends MessageType<PropertyInfo> {
    constructor() {
        super("sushi_rpc.PropertyInfo", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PropertyInfo>): PropertyInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.name = "";
        message.label = "";
        if (value !== undefined)
            reflectionMergePartial<PropertyInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PropertyInfo): PropertyInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string label */ 3:
                    message.label = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PropertyInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string label = 3; */
        if (message.label !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.label);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.PropertyInfo
 */
export const PropertyInfo = new PropertyInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropertyInfoList$Type extends MessageType<PropertyInfoList> {
    constructor() {
        super("sushi_rpc.PropertyInfoList", [
            { no: 1, name: "properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PropertyInfo }
        ]);
    }
    create(value?: PartialMessage<PropertyInfoList>): PropertyInfoList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.properties = [];
        if (value !== undefined)
            reflectionMergePartial<PropertyInfoList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PropertyInfoList): PropertyInfoList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sushi_rpc.PropertyInfo properties */ 1:
                    message.properties.push(PropertyInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PropertyInfoList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sushi_rpc.PropertyInfo properties = 1; */
        for (let i = 0; i < message.properties.length; i++)
            PropertyInfo.internalBinaryWrite(message.properties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.PropertyInfoList
 */
export const PropertyInfoList = new PropertyInfoList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropertyValue$Type extends MessageType<PropertyValue> {
    constructor() {
        super("sushi_rpc.PropertyValue", [
            { no: 1, name: "property", kind: "message", T: () => PropertyIdentifier },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PropertyValue>): PropertyValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<PropertyValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PropertyValue): PropertyValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.PropertyIdentifier property */ 1:
                    message.property = PropertyIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.property);
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PropertyValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.PropertyIdentifier property = 1; */
        if (message.property)
            PropertyIdentifier.internalBinaryWrite(message.property, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.PropertyValue
 */
export const PropertyValue = new PropertyValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropertyIdRequest$Type extends MessageType<PropertyIdRequest> {
    constructor() {
        super("sushi_rpc.PropertyIdRequest", [
            { no: 1, name: "processor", kind: "message", T: () => ProcessorIdentifier },
            { no: 2, name: "property_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PropertyIdRequest>): PropertyIdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.propertyName = "";
        if (value !== undefined)
            reflectionMergePartial<PropertyIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PropertyIdRequest): PropertyIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ProcessorIdentifier processor */ 1:
                    message.processor = ProcessorIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.processor);
                    break;
                case /* string property_name */ 2:
                    message.propertyName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PropertyIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ProcessorIdentifier processor = 1; */
        if (message.processor)
            ProcessorIdentifier.internalBinaryWrite(message.processor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string property_name = 2; */
        if (message.propertyName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.propertyName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.PropertyIdRequest
 */
export const PropertyIdRequest = new PropertyIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginType$Type extends MessageType<PluginType> {
    constructor() {
        super("sushi_rpc.PluginType", [
            { no: 1, name: "type", kind: "enum", T: () => ["sushi_rpc.PluginType.Type", PluginType_Type] }
        ]);
    }
    create(value?: PartialMessage<PluginType>): PluginType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<PluginType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginType): PluginType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.PluginType.Type type */ 1:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.PluginType.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.PluginType
 */
export const PluginType = new PluginType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessorPosition$Type extends MessageType<ProcessorPosition> {
    constructor() {
        super("sushi_rpc.ProcessorPosition", [
            { no: 1, name: "add_to_back", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "before_processor", kind: "message", T: () => ProcessorIdentifier }
        ]);
    }
    create(value?: PartialMessage<ProcessorPosition>): ProcessorPosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addToBack = false;
        if (value !== undefined)
            reflectionMergePartial<ProcessorPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessorPosition): ProcessorPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool add_to_back */ 1:
                    message.addToBack = reader.bool();
                    break;
                case /* sushi_rpc.ProcessorIdentifier before_processor */ 2:
                    message.beforeProcessor = ProcessorIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.beforeProcessor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessorPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool add_to_back = 1; */
        if (message.addToBack !== false)
            writer.tag(1, WireType.Varint).bool(message.addToBack);
        /* sushi_rpc.ProcessorIdentifier before_processor = 2; */
        if (message.beforeProcessor)
            ProcessorIdentifier.internalBinaryWrite(message.beforeProcessor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ProcessorPosition
 */
export const ProcessorPosition = new ProcessorPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateTrackRequest$Type extends MessageType<CreateTrackRequest> {
    constructor() {
        super("sushi_rpc.CreateTrackRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channels", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CreateTrackRequest>): CreateTrackRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.channels = 0;
        if (value !== undefined)
            reflectionMergePartial<CreateTrackRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateTrackRequest): CreateTrackRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 channels */ 2:
                    message.channels = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateTrackRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 channels = 2; */
        if (message.channels !== 0)
            writer.tag(2, WireType.Varint).int32(message.channels);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.CreateTrackRequest
 */
export const CreateTrackRequest = new CreateTrackRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateMultibusTrackRequest$Type extends MessageType<CreateMultibusTrackRequest> {
    constructor() {
        super("sushi_rpc.CreateMultibusTrackRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "buses", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CreateMultibusTrackRequest>): CreateMultibusTrackRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.buses = 0;
        if (value !== undefined)
            reflectionMergePartial<CreateMultibusTrackRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateMultibusTrackRequest): CreateMultibusTrackRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 buses */ 2:
                    message.buses = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateMultibusTrackRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 buses = 2; */
        if (message.buses !== 0)
            writer.tag(2, WireType.Varint).int32(message.buses);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.CreateMultibusTrackRequest
 */
export const CreateMultibusTrackRequest = new CreateMultibusTrackRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatePreTrackRequest$Type extends MessageType<CreatePreTrackRequest> {
    constructor() {
        super("sushi_rpc.CreatePreTrackRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreatePreTrackRequest>): CreatePreTrackRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<CreatePreTrackRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatePreTrackRequest): CreatePreTrackRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatePreTrackRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.CreatePreTrackRequest
 */
export const CreatePreTrackRequest = new CreatePreTrackRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatePostTrackRequest$Type extends MessageType<CreatePostTrackRequest> {
    constructor() {
        super("sushi_rpc.CreatePostTrackRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreatePostTrackRequest>): CreatePostTrackRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<CreatePostTrackRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatePostTrackRequest): CreatePostTrackRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatePostTrackRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.CreatePostTrackRequest
 */
export const CreatePostTrackRequest = new CreatePostTrackRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateProcessorRequest$Type extends MessageType<CreateProcessorRequest> {
    constructor() {
        super("sushi_rpc.CreateProcessorRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "type", kind: "message", T: () => PluginType },
            { no: 5, name: "track", kind: "message", T: () => TrackIdentifier },
            { no: 6, name: "position", kind: "message", T: () => ProcessorPosition }
        ]);
    }
    create(value?: PartialMessage<CreateProcessorRequest>): CreateProcessorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.uid = "";
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial<CreateProcessorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateProcessorRequest): CreateProcessorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string uid */ 2:
                    message.uid = reader.string();
                    break;
                case /* string path */ 3:
                    message.path = reader.string();
                    break;
                case /* sushi_rpc.PluginType type */ 4:
                    message.type = PluginType.internalBinaryRead(reader, reader.uint32(), options, message.type);
                    break;
                case /* sushi_rpc.TrackIdentifier track */ 5:
                    message.track = TrackIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.track);
                    break;
                case /* sushi_rpc.ProcessorPosition position */ 6:
                    message.position = ProcessorPosition.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateProcessorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string uid = 2; */
        if (message.uid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uid);
        /* string path = 3; */
        if (message.path !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.path);
        /* sushi_rpc.PluginType type = 4; */
        if (message.type)
            PluginType.internalBinaryWrite(message.type, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.TrackIdentifier track = 5; */
        if (message.track)
            TrackIdentifier.internalBinaryWrite(message.track, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.ProcessorPosition position = 6; */
        if (message.position)
            ProcessorPosition.internalBinaryWrite(message.position, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.CreateProcessorRequest
 */
export const CreateProcessorRequest = new CreateProcessorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveProcessorRequest$Type extends MessageType<MoveProcessorRequest> {
    constructor() {
        super("sushi_rpc.MoveProcessorRequest", [
            { no: 1, name: "processor", kind: "message", T: () => ProcessorIdentifier },
            { no: 2, name: "source_track", kind: "message", T: () => TrackIdentifier },
            { no: 3, name: "dest_track", kind: "message", T: () => TrackIdentifier },
            { no: 4, name: "position", kind: "message", T: () => ProcessorPosition }
        ]);
    }
    create(value?: PartialMessage<MoveProcessorRequest>): MoveProcessorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MoveProcessorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveProcessorRequest): MoveProcessorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ProcessorIdentifier processor */ 1:
                    message.processor = ProcessorIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.processor);
                    break;
                case /* sushi_rpc.TrackIdentifier source_track */ 2:
                    message.sourceTrack = TrackIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.sourceTrack);
                    break;
                case /* sushi_rpc.TrackIdentifier dest_track */ 3:
                    message.destTrack = TrackIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.destTrack);
                    break;
                case /* sushi_rpc.ProcessorPosition position */ 4:
                    message.position = ProcessorPosition.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveProcessorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ProcessorIdentifier processor = 1; */
        if (message.processor)
            ProcessorIdentifier.internalBinaryWrite(message.processor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.TrackIdentifier source_track = 2; */
        if (message.sourceTrack)
            TrackIdentifier.internalBinaryWrite(message.sourceTrack, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.TrackIdentifier dest_track = 3; */
        if (message.destTrack)
            TrackIdentifier.internalBinaryWrite(message.destTrack, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.ProcessorPosition position = 4; */
        if (message.position)
            ProcessorPosition.internalBinaryWrite(message.position, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.MoveProcessorRequest
 */
export const MoveProcessorRequest = new MoveProcessorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteProcessorRequest$Type extends MessageType<DeleteProcessorRequest> {
    constructor() {
        super("sushi_rpc.DeleteProcessorRequest", [
            { no: 1, name: "processor", kind: "message", T: () => ProcessorIdentifier },
            { no: 2, name: "track", kind: "message", T: () => TrackIdentifier }
        ]);
    }
    create(value?: PartialMessage<DeleteProcessorRequest>): DeleteProcessorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteProcessorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteProcessorRequest): DeleteProcessorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ProcessorIdentifier processor */ 1:
                    message.processor = ProcessorIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.processor);
                    break;
                case /* sushi_rpc.TrackIdentifier track */ 2:
                    message.track = TrackIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.track);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteProcessorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ProcessorIdentifier processor = 1; */
        if (message.processor)
            ProcessorIdentifier.internalBinaryWrite(message.processor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.TrackIdentifier track = 2; */
        if (message.track)
            TrackIdentifier.internalBinaryWrite(message.track, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.DeleteProcessorRequest
 */
export const DeleteProcessorRequest = new DeleteProcessorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParameterNotificationBlocklist$Type extends MessageType<ParameterNotificationBlocklist> {
    constructor() {
        super("sushi_rpc.ParameterNotificationBlocklist", [
            { no: 1, name: "parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ParameterIdentifier }
        ]);
    }
    create(value?: PartialMessage<ParameterNotificationBlocklist>): ParameterNotificationBlocklist {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parameters = [];
        if (value !== undefined)
            reflectionMergePartial<ParameterNotificationBlocklist>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParameterNotificationBlocklist): ParameterNotificationBlocklist {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sushi_rpc.ParameterIdentifier parameters */ 1:
                    message.parameters.push(ParameterIdentifier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParameterNotificationBlocklist, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sushi_rpc.ParameterIdentifier parameters = 1; */
        for (let i = 0; i < message.parameters.length; i++)
            ParameterIdentifier.internalBinaryWrite(message.parameters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ParameterNotificationBlocklist
 */
export const ParameterNotificationBlocklist = new ParameterNotificationBlocklist$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropertyNotificationBlocklist$Type extends MessageType<PropertyNotificationBlocklist> {
    constructor() {
        super("sushi_rpc.PropertyNotificationBlocklist", [
            { no: 1, name: "properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PropertyIdentifier }
        ]);
    }
    create(value?: PartialMessage<PropertyNotificationBlocklist>): PropertyNotificationBlocklist {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.properties = [];
        if (value !== undefined)
            reflectionMergePartial<PropertyNotificationBlocklist>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PropertyNotificationBlocklist): PropertyNotificationBlocklist {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sushi_rpc.PropertyIdentifier properties */ 1:
                    message.properties.push(PropertyIdentifier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PropertyNotificationBlocklist, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sushi_rpc.PropertyIdentifier properties = 1; */
        for (let i = 0; i < message.properties.length; i++)
            PropertyIdentifier.internalBinaryWrite(message.properties[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.PropertyNotificationBlocklist
 */
export const PropertyNotificationBlocklist = new PropertyNotificationBlocklist$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MidiChannel$Type extends MessageType<MidiChannel> {
    constructor() {
        super("sushi_rpc.MidiChannel", [
            { no: 1, name: "channel", kind: "enum", T: () => ["sushi_rpc.MidiChannel.Channel", MidiChannel_Channel] }
        ]);
    }
    create(value?: PartialMessage<MidiChannel>): MidiChannel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.channel = 0;
        if (value !== undefined)
            reflectionMergePartial<MidiChannel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MidiChannel): MidiChannel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.MidiChannel.Channel channel */ 1:
                    message.channel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MidiChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.MidiChannel.Channel channel = 1; */
        if (message.channel !== 0)
            writer.tag(1, WireType.Varint).int32(message.channel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.MidiChannel
 */
export const MidiChannel = new MidiChannel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AudioConnection$Type extends MessageType<AudioConnection> {
    constructor() {
        super("sushi_rpc.AudioConnection", [
            { no: 1, name: "track", kind: "message", T: () => TrackIdentifier },
            { no: 2, name: "track_channel", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "engine_channel", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AudioConnection>): AudioConnection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trackChannel = 0;
        message.engineChannel = 0;
        if (value !== undefined)
            reflectionMergePartial<AudioConnection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AudioConnection): AudioConnection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.TrackIdentifier track */ 1:
                    message.track = TrackIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.track);
                    break;
                case /* int32 track_channel */ 2:
                    message.trackChannel = reader.int32();
                    break;
                case /* int32 engine_channel */ 3:
                    message.engineChannel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AudioConnection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.TrackIdentifier track = 1; */
        if (message.track)
            TrackIdentifier.internalBinaryWrite(message.track, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 track_channel = 2; */
        if (message.trackChannel !== 0)
            writer.tag(2, WireType.Varint).int32(message.trackChannel);
        /* int32 engine_channel = 3; */
        if (message.engineChannel !== 0)
            writer.tag(3, WireType.Varint).int32(message.engineChannel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.AudioConnection
 */
export const AudioConnection = new AudioConnection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AudioConnectionList$Type extends MessageType<AudioConnectionList> {
    constructor() {
        super("sushi_rpc.AudioConnectionList", [
            { no: 1, name: "connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AudioConnection }
        ]);
    }
    create(value?: PartialMessage<AudioConnectionList>): AudioConnectionList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connections = [];
        if (value !== undefined)
            reflectionMergePartial<AudioConnectionList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AudioConnectionList): AudioConnectionList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sushi_rpc.AudioConnection connections */ 1:
                    message.connections.push(AudioConnection.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AudioConnectionList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sushi_rpc.AudioConnection connections = 1; */
        for (let i = 0; i < message.connections.length; i++)
            AudioConnection.internalBinaryWrite(message.connections[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.AudioConnectionList
 */
export const AudioConnectionList = new AudioConnectionList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CvConnection$Type extends MessageType<CvConnection> {
    constructor() {
        super("sushi_rpc.CvConnection", [
            { no: 1, name: "parameter", kind: "message", T: () => ParameterIdentifier },
            { no: 2, name: "cv_port_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CvConnection>): CvConnection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cvPortId = 0;
        if (value !== undefined)
            reflectionMergePartial<CvConnection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CvConnection): CvConnection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ParameterIdentifier parameter */ 1:
                    message.parameter = ParameterIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.parameter);
                    break;
                case /* int32 cv_port_id */ 2:
                    message.cvPortId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CvConnection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ParameterIdentifier parameter = 1; */
        if (message.parameter)
            ParameterIdentifier.internalBinaryWrite(message.parameter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 cv_port_id = 2; */
        if (message.cvPortId !== 0)
            writer.tag(2, WireType.Varint).int32(message.cvPortId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.CvConnection
 */
export const CvConnection = new CvConnection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CvConnectionList$Type extends MessageType<CvConnectionList> {
    constructor() {
        super("sushi_rpc.CvConnectionList", [
            { no: 1, name: "connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CvConnection }
        ]);
    }
    create(value?: PartialMessage<CvConnectionList>): CvConnectionList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connections = [];
        if (value !== undefined)
            reflectionMergePartial<CvConnectionList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CvConnectionList): CvConnectionList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sushi_rpc.CvConnection connections */ 1:
                    message.connections.push(CvConnection.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CvConnectionList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sushi_rpc.CvConnection connections = 1; */
        for (let i = 0; i < message.connections.length; i++)
            CvConnection.internalBinaryWrite(message.connections[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.CvConnectionList
 */
export const CvConnectionList = new CvConnectionList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GateConnection$Type extends MessageType<GateConnection> {
    constructor() {
        super("sushi_rpc.GateConnection", [
            { no: 1, name: "processor", kind: "message", T: () => ProcessorIdentifier },
            { no: 2, name: "gate_port_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "channel", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "note_no", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GateConnection>): GateConnection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gatePortId = 0;
        message.channel = 0;
        message.noteNo = 0;
        if (value !== undefined)
            reflectionMergePartial<GateConnection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GateConnection): GateConnection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ProcessorIdentifier processor */ 1:
                    message.processor = ProcessorIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.processor);
                    break;
                case /* int32 gate_port_id */ 2:
                    message.gatePortId = reader.int32();
                    break;
                case /* int32 channel */ 3:
                    message.channel = reader.int32();
                    break;
                case /* int32 note_no */ 4:
                    message.noteNo = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GateConnection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ProcessorIdentifier processor = 1; */
        if (message.processor)
            ProcessorIdentifier.internalBinaryWrite(message.processor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 gate_port_id = 2; */
        if (message.gatePortId !== 0)
            writer.tag(2, WireType.Varint).int32(message.gatePortId);
        /* int32 channel = 3; */
        if (message.channel !== 0)
            writer.tag(3, WireType.Varint).int32(message.channel);
        /* int32 note_no = 4; */
        if (message.noteNo !== 0)
            writer.tag(4, WireType.Varint).int32(message.noteNo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.GateConnection
 */
export const GateConnection = new GateConnection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GateConnectionList$Type extends MessageType<GateConnectionList> {
    constructor() {
        super("sushi_rpc.GateConnectionList", [
            { no: 1, name: "connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GateConnection }
        ]);
    }
    create(value?: PartialMessage<GateConnectionList>): GateConnectionList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connections = [];
        if (value !== undefined)
            reflectionMergePartial<GateConnectionList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GateConnectionList): GateConnectionList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sushi_rpc.GateConnection connections */ 1:
                    message.connections.push(GateConnection.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GateConnectionList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sushi_rpc.GateConnection connections = 1; */
        for (let i = 0; i < message.connections.length; i++)
            GateConnection.internalBinaryWrite(message.connections[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.GateConnectionList
 */
export const GateConnectionList = new GateConnectionList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MidiKbdConnection$Type extends MessageType<MidiKbdConnection> {
    constructor() {
        super("sushi_rpc.MidiKbdConnection", [
            { no: 1, name: "track", kind: "message", T: () => TrackIdentifier },
            { no: 2, name: "channel", kind: "message", T: () => MidiChannel },
            { no: 3, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "raw_midi", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MidiKbdConnection>): MidiKbdConnection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.port = 0;
        message.rawMidi = false;
        if (value !== undefined)
            reflectionMergePartial<MidiKbdConnection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MidiKbdConnection): MidiKbdConnection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.TrackIdentifier track */ 1:
                    message.track = TrackIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.track);
                    break;
                case /* sushi_rpc.MidiChannel channel */ 2:
                    message.channel = MidiChannel.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                case /* int32 port */ 3:
                    message.port = reader.int32();
                    break;
                case /* bool raw_midi */ 7:
                    message.rawMidi = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MidiKbdConnection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.TrackIdentifier track = 1; */
        if (message.track)
            TrackIdentifier.internalBinaryWrite(message.track, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.MidiChannel channel = 2; */
        if (message.channel)
            MidiChannel.internalBinaryWrite(message.channel, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 port = 3; */
        if (message.port !== 0)
            writer.tag(3, WireType.Varint).int32(message.port);
        /* bool raw_midi = 7; */
        if (message.rawMidi !== false)
            writer.tag(7, WireType.Varint).bool(message.rawMidi);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.MidiKbdConnection
 */
export const MidiKbdConnection = new MidiKbdConnection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MidiKbdConnectionList$Type extends MessageType<MidiKbdConnectionList> {
    constructor() {
        super("sushi_rpc.MidiKbdConnectionList", [
            { no: 1, name: "connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MidiKbdConnection }
        ]);
    }
    create(value?: PartialMessage<MidiKbdConnectionList>): MidiKbdConnectionList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connections = [];
        if (value !== undefined)
            reflectionMergePartial<MidiKbdConnectionList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MidiKbdConnectionList): MidiKbdConnectionList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sushi_rpc.MidiKbdConnection connections */ 1:
                    message.connections.push(MidiKbdConnection.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MidiKbdConnectionList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sushi_rpc.MidiKbdConnection connections = 1; */
        for (let i = 0; i < message.connections.length; i++)
            MidiKbdConnection.internalBinaryWrite(message.connections[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.MidiKbdConnectionList
 */
export const MidiKbdConnectionList = new MidiKbdConnectionList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MidiCCConnection$Type extends MessageType<MidiCCConnection> {
    constructor() {
        super("sushi_rpc.MidiCCConnection", [
            { no: 1, name: "parameter", kind: "message", T: () => ParameterIdentifier },
            { no: 2, name: "channel", kind: "message", T: () => MidiChannel },
            { no: 3, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "cc_number", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "min_range", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "max_range", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "relative_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MidiCCConnection>): MidiCCConnection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.port = 0;
        message.ccNumber = 0;
        message.minRange = 0;
        message.maxRange = 0;
        message.relativeMode = false;
        if (value !== undefined)
            reflectionMergePartial<MidiCCConnection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MidiCCConnection): MidiCCConnection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ParameterIdentifier parameter */ 1:
                    message.parameter = ParameterIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.parameter);
                    break;
                case /* sushi_rpc.MidiChannel channel */ 2:
                    message.channel = MidiChannel.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                case /* int32 port */ 3:
                    message.port = reader.int32();
                    break;
                case /* int32 cc_number */ 4:
                    message.ccNumber = reader.int32();
                    break;
                case /* float min_range */ 5:
                    message.minRange = reader.float();
                    break;
                case /* float max_range */ 6:
                    message.maxRange = reader.float();
                    break;
                case /* bool relative_mode */ 7:
                    message.relativeMode = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MidiCCConnection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ParameterIdentifier parameter = 1; */
        if (message.parameter)
            ParameterIdentifier.internalBinaryWrite(message.parameter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.MidiChannel channel = 2; */
        if (message.channel)
            MidiChannel.internalBinaryWrite(message.channel, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 port = 3; */
        if (message.port !== 0)
            writer.tag(3, WireType.Varint).int32(message.port);
        /* int32 cc_number = 4; */
        if (message.ccNumber !== 0)
            writer.tag(4, WireType.Varint).int32(message.ccNumber);
        /* float min_range = 5; */
        if (message.minRange !== 0)
            writer.tag(5, WireType.Bit32).float(message.minRange);
        /* float max_range = 6; */
        if (message.maxRange !== 0)
            writer.tag(6, WireType.Bit32).float(message.maxRange);
        /* bool relative_mode = 7; */
        if (message.relativeMode !== false)
            writer.tag(7, WireType.Varint).bool(message.relativeMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.MidiCCConnection
 */
export const MidiCCConnection = new MidiCCConnection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MidiCCConnectionList$Type extends MessageType<MidiCCConnectionList> {
    constructor() {
        super("sushi_rpc.MidiCCConnectionList", [
            { no: 1, name: "connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MidiCCConnection }
        ]);
    }
    create(value?: PartialMessage<MidiCCConnectionList>): MidiCCConnectionList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connections = [];
        if (value !== undefined)
            reflectionMergePartial<MidiCCConnectionList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MidiCCConnectionList): MidiCCConnectionList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sushi_rpc.MidiCCConnection connections */ 1:
                    message.connections.push(MidiCCConnection.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MidiCCConnectionList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sushi_rpc.MidiCCConnection connections = 1; */
        for (let i = 0; i < message.connections.length; i++)
            MidiCCConnection.internalBinaryWrite(message.connections[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.MidiCCConnectionList
 */
export const MidiCCConnectionList = new MidiCCConnectionList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MidiPCConnection$Type extends MessageType<MidiPCConnection> {
    constructor() {
        super("sushi_rpc.MidiPCConnection", [
            { no: 1, name: "processor", kind: "message", T: () => ProcessorIdentifier },
            { no: 2, name: "channel", kind: "message", T: () => MidiChannel },
            { no: 3, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MidiPCConnection>): MidiPCConnection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.port = 0;
        if (value !== undefined)
            reflectionMergePartial<MidiPCConnection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MidiPCConnection): MidiPCConnection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ProcessorIdentifier processor */ 1:
                    message.processor = ProcessorIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.processor);
                    break;
                case /* sushi_rpc.MidiChannel channel */ 2:
                    message.channel = MidiChannel.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                case /* int32 port */ 3:
                    message.port = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MidiPCConnection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ProcessorIdentifier processor = 1; */
        if (message.processor)
            ProcessorIdentifier.internalBinaryWrite(message.processor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.MidiChannel channel = 2; */
        if (message.channel)
            MidiChannel.internalBinaryWrite(message.channel, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 port = 3; */
        if (message.port !== 0)
            writer.tag(3, WireType.Varint).int32(message.port);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.MidiPCConnection
 */
export const MidiPCConnection = new MidiPCConnection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MidiPCConnectionList$Type extends MessageType<MidiPCConnectionList> {
    constructor() {
        super("sushi_rpc.MidiPCConnectionList", [
            { no: 1, name: "connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MidiPCConnection }
        ]);
    }
    create(value?: PartialMessage<MidiPCConnectionList>): MidiPCConnectionList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connections = [];
        if (value !== undefined)
            reflectionMergePartial<MidiPCConnectionList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MidiPCConnectionList): MidiPCConnectionList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sushi_rpc.MidiPCConnection connections */ 1:
                    message.connections.push(MidiPCConnection.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MidiPCConnectionList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sushi_rpc.MidiPCConnection connections = 1; */
        for (let i = 0; i < message.connections.length; i++)
            MidiPCConnection.internalBinaryWrite(message.connections[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.MidiPCConnectionList
 */
export const MidiPCConnectionList = new MidiPCConnectionList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MidiClockSetRequest$Type extends MessageType<MidiClockSetRequest> {
    constructor() {
        super("sushi_rpc.MidiClockSetRequest", [
            { no: 1, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MidiClockSetRequest>): MidiClockSetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.port = 0;
        message.enabled = false;
        if (value !== undefined)
            reflectionMergePartial<MidiClockSetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MidiClockSetRequest): MidiClockSetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 port */ 1:
                    message.port = reader.int32();
                    break;
                case /* bool enabled */ 2:
                    message.enabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MidiClockSetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 port = 1; */
        if (message.port !== 0)
            writer.tag(1, WireType.Varint).int32(message.port);
        /* bool enabled = 2; */
        if (message.enabled !== false)
            writer.tag(2, WireType.Varint).bool(message.enabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.MidiClockSetRequest
 */
export const MidiClockSetRequest = new MidiClockSetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OscParameterOutputList$Type extends MessageType<OscParameterOutputList> {
    constructor() {
        super("sushi_rpc.OscParameterOutputList", [
            { no: 1, name: "path", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OscParameterOutputList>): OscParameterOutputList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = [];
        if (value !== undefined)
            reflectionMergePartial<OscParameterOutputList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OscParameterOutputList): OscParameterOutputList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string path */ 1:
                    message.path.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OscParameterOutputList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string path = 1; */
        for (let i = 0; i < message.path.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.path[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.OscParameterOutputList
 */
export const OscParameterOutputList = new OscParameterOutputList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransportUpdate$Type extends MessageType<TransportUpdate> {
    constructor() {
        super("sushi_rpc.TransportUpdate", [
            { no: 1, name: "tempo", kind: "scalar", oneof: "transport", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "playing_mode", kind: "message", oneof: "transport", T: () => PlayingMode },
            { no: 3, name: "sync_mode", kind: "message", oneof: "transport", T: () => SyncMode },
            { no: 4, name: "time_signature", kind: "message", oneof: "transport", T: () => TimeSignature }
        ]);
    }
    create(value?: PartialMessage<TransportUpdate>): TransportUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transport = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TransportUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransportUpdate): TransportUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float tempo */ 1:
                    message.transport = {
                        oneofKind: "tempo",
                        tempo: reader.float()
                    };
                    break;
                case /* sushi_rpc.PlayingMode playing_mode */ 2:
                    message.transport = {
                        oneofKind: "playingMode",
                        playingMode: PlayingMode.internalBinaryRead(reader, reader.uint32(), options, (message.transport as any).playingMode)
                    };
                    break;
                case /* sushi_rpc.SyncMode sync_mode */ 3:
                    message.transport = {
                        oneofKind: "syncMode",
                        syncMode: SyncMode.internalBinaryRead(reader, reader.uint32(), options, (message.transport as any).syncMode)
                    };
                    break;
                case /* sushi_rpc.TimeSignature time_signature */ 4:
                    message.transport = {
                        oneofKind: "timeSignature",
                        timeSignature: TimeSignature.internalBinaryRead(reader, reader.uint32(), options, (message.transport as any).timeSignature)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransportUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float tempo = 1; */
        if (message.transport.oneofKind === "tempo")
            writer.tag(1, WireType.Bit32).float(message.transport.tempo);
        /* sushi_rpc.PlayingMode playing_mode = 2; */
        if (message.transport.oneofKind === "playingMode")
            PlayingMode.internalBinaryWrite(message.transport.playingMode, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.SyncMode sync_mode = 3; */
        if (message.transport.oneofKind === "syncMode")
            SyncMode.internalBinaryWrite(message.transport.syncMode, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.TimeSignature time_signature = 4; */
        if (message.transport.oneofKind === "timeSignature")
            TimeSignature.internalBinaryWrite(message.transport.timeSignature, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.TransportUpdate
 */
export const TransportUpdate = new TransportUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackUpdate$Type extends MessageType<TrackUpdate> {
    constructor() {
        super("sushi_rpc.TrackUpdate", [
            { no: 1, name: "action", kind: "enum", T: () => ["sushi_rpc.TrackUpdate.Action", TrackUpdate_Action] },
            { no: 2, name: "track", kind: "message", T: () => TrackIdentifier }
        ]);
    }
    create(value?: PartialMessage<TrackUpdate>): TrackUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        if (value !== undefined)
            reflectionMergePartial<TrackUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackUpdate): TrackUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.TrackUpdate.Action action */ 1:
                    message.action = reader.int32();
                    break;
                case /* sushi_rpc.TrackIdentifier track */ 2:
                    message.track = TrackIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.track);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.TrackUpdate.Action action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* sushi_rpc.TrackIdentifier track = 2; */
        if (message.track)
            TrackIdentifier.internalBinaryWrite(message.track, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.TrackUpdate
 */
export const TrackUpdate = new TrackUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessorUpdate$Type extends MessageType<ProcessorUpdate> {
    constructor() {
        super("sushi_rpc.ProcessorUpdate", [
            { no: 1, name: "action", kind: "enum", T: () => ["sushi_rpc.ProcessorUpdate.Action", ProcessorUpdate_Action] },
            { no: 2, name: "processor", kind: "message", T: () => ProcessorIdentifier },
            { no: 3, name: "parent_track", kind: "message", T: () => TrackIdentifier }
        ]);
    }
    create(value?: PartialMessage<ProcessorUpdate>): ProcessorUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        if (value !== undefined)
            reflectionMergePartial<ProcessorUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessorUpdate): ProcessorUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.ProcessorUpdate.Action action */ 1:
                    message.action = reader.int32();
                    break;
                case /* sushi_rpc.ProcessorIdentifier processor */ 2:
                    message.processor = ProcessorIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.processor);
                    break;
                case /* sushi_rpc.TrackIdentifier parent_track */ 3:
                    message.parentTrack = TrackIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.parentTrack);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessorUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.ProcessorUpdate.Action action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* sushi_rpc.ProcessorIdentifier processor = 2; */
        if (message.processor)
            ProcessorIdentifier.internalBinaryWrite(message.processor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.TrackIdentifier parent_track = 3; */
        if (message.parentTrack)
            TrackIdentifier.internalBinaryWrite(message.parentTrack, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.ProcessorUpdate
 */
export const ProcessorUpdate = new ProcessorUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MidiKbdConnectionState$Type extends MessageType<MidiKbdConnectionState> {
    constructor() {
        super("sushi_rpc.MidiKbdConnectionState", [
            { no: 1, name: "track", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel", kind: "message", T: () => MidiChannel },
            { no: 3, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "raw_midi", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MidiKbdConnectionState>): MidiKbdConnectionState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.track = "";
        message.port = 0;
        message.rawMidi = false;
        if (value !== undefined)
            reflectionMergePartial<MidiKbdConnectionState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MidiKbdConnectionState): MidiKbdConnectionState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string track */ 1:
                    message.track = reader.string();
                    break;
                case /* sushi_rpc.MidiChannel channel */ 2:
                    message.channel = MidiChannel.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                case /* int32 port */ 3:
                    message.port = reader.int32();
                    break;
                case /* bool raw_midi */ 7:
                    message.rawMidi = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MidiKbdConnectionState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string track = 1; */
        if (message.track !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.track);
        /* sushi_rpc.MidiChannel channel = 2; */
        if (message.channel)
            MidiChannel.internalBinaryWrite(message.channel, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 port = 3; */
        if (message.port !== 0)
            writer.tag(3, WireType.Varint).int32(message.port);
        /* bool raw_midi = 7; */
        if (message.rawMidi !== false)
            writer.tag(7, WireType.Varint).bool(message.rawMidi);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.MidiKbdConnectionState
 */
export const MidiKbdConnectionState = new MidiKbdConnectionState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MidiCCConnectionState$Type extends MessageType<MidiCCConnectionState> {
    constructor() {
        super("sushi_rpc.MidiCCConnectionState", [
            { no: 1, name: "processor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "parameter", kind: "message", T: () => ParameterIdentifier },
            { no: 3, name: "channel", kind: "message", T: () => MidiChannel },
            { no: 4, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "cc_number", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "min_range", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "max_range", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "relative_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MidiCCConnectionState>): MidiCCConnectionState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.processor = "";
        message.port = 0;
        message.ccNumber = 0;
        message.minRange = 0;
        message.maxRange = 0;
        message.relativeMode = false;
        if (value !== undefined)
            reflectionMergePartial<MidiCCConnectionState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MidiCCConnectionState): MidiCCConnectionState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string processor */ 1:
                    message.processor = reader.string();
                    break;
                case /* sushi_rpc.ParameterIdentifier parameter */ 2:
                    message.parameter = ParameterIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.parameter);
                    break;
                case /* sushi_rpc.MidiChannel channel */ 3:
                    message.channel = MidiChannel.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                case /* int32 port */ 4:
                    message.port = reader.int32();
                    break;
                case /* int32 cc_number */ 5:
                    message.ccNumber = reader.int32();
                    break;
                case /* float min_range */ 6:
                    message.minRange = reader.float();
                    break;
                case /* float max_range */ 7:
                    message.maxRange = reader.float();
                    break;
                case /* bool relative_mode */ 8:
                    message.relativeMode = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MidiCCConnectionState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string processor = 1; */
        if (message.processor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.processor);
        /* sushi_rpc.ParameterIdentifier parameter = 2; */
        if (message.parameter)
            ParameterIdentifier.internalBinaryWrite(message.parameter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.MidiChannel channel = 3; */
        if (message.channel)
            MidiChannel.internalBinaryWrite(message.channel, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int32 port = 4; */
        if (message.port !== 0)
            writer.tag(4, WireType.Varint).int32(message.port);
        /* int32 cc_number = 5; */
        if (message.ccNumber !== 0)
            writer.tag(5, WireType.Varint).int32(message.ccNumber);
        /* float min_range = 6; */
        if (message.minRange !== 0)
            writer.tag(6, WireType.Bit32).float(message.minRange);
        /* float max_range = 7; */
        if (message.maxRange !== 0)
            writer.tag(7, WireType.Bit32).float(message.maxRange);
        /* bool relative_mode = 8; */
        if (message.relativeMode !== false)
            writer.tag(8, WireType.Varint).bool(message.relativeMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.MidiCCConnectionState
 */
export const MidiCCConnectionState = new MidiCCConnectionState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MidiPCConnectionState$Type extends MessageType<MidiPCConnectionState> {
    constructor() {
        super("sushi_rpc.MidiPCConnectionState", [
            { no: 1, name: "processor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel", kind: "message", T: () => MidiChannel },
            { no: 3, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MidiPCConnectionState>): MidiPCConnectionState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.processor = "";
        message.port = 0;
        if (value !== undefined)
            reflectionMergePartial<MidiPCConnectionState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MidiPCConnectionState): MidiPCConnectionState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string processor */ 1:
                    message.processor = reader.string();
                    break;
                case /* sushi_rpc.MidiChannel channel */ 2:
                    message.channel = MidiChannel.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                case /* int32 port */ 3:
                    message.port = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MidiPCConnectionState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string processor = 1; */
        if (message.processor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.processor);
        /* sushi_rpc.MidiChannel channel = 2; */
        if (message.channel)
            MidiChannel.internalBinaryWrite(message.channel, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 port = 3; */
        if (message.port !== 0)
            writer.tag(3, WireType.Varint).int32(message.port);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.MidiPCConnectionState
 */
export const MidiPCConnectionState = new MidiPCConnectionState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MidiState$Type extends MessageType<MidiState> {
    constructor() {
        super("sushi_rpc.MidiState", [
            { no: 1, name: "inputs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "outputs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "kbd_input_connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MidiKbdConnectionState },
            { no: 4, name: "kbd_output_connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MidiKbdConnectionState },
            { no: 5, name: "cc_connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MidiCCConnectionState },
            { no: 6, name: "pc_connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MidiPCConnectionState },
            { no: 7, name: "enabled_clock_outputs", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MidiState>): MidiState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inputs = 0;
        message.outputs = 0;
        message.kbdInputConnections = [];
        message.kbdOutputConnections = [];
        message.ccConnections = [];
        message.pcConnections = [];
        message.enabledClockOutputs = [];
        if (value !== undefined)
            reflectionMergePartial<MidiState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MidiState): MidiState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 inputs */ 1:
                    message.inputs = reader.int32();
                    break;
                case /* int32 outputs */ 2:
                    message.outputs = reader.int32();
                    break;
                case /* repeated sushi_rpc.MidiKbdConnectionState kbd_input_connections */ 3:
                    message.kbdInputConnections.push(MidiKbdConnectionState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated sushi_rpc.MidiKbdConnectionState kbd_output_connections */ 4:
                    message.kbdOutputConnections.push(MidiKbdConnectionState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated sushi_rpc.MidiCCConnectionState cc_connections */ 5:
                    message.ccConnections.push(MidiCCConnectionState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated sushi_rpc.MidiPCConnectionState pc_connections */ 6:
                    message.pcConnections.push(MidiPCConnectionState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated int32 enabled_clock_outputs */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.enabledClockOutputs.push(reader.int32());
                    else
                        message.enabledClockOutputs.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MidiState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 inputs = 1; */
        if (message.inputs !== 0)
            writer.tag(1, WireType.Varint).int32(message.inputs);
        /* int32 outputs = 2; */
        if (message.outputs !== 0)
            writer.tag(2, WireType.Varint).int32(message.outputs);
        /* repeated sushi_rpc.MidiKbdConnectionState kbd_input_connections = 3; */
        for (let i = 0; i < message.kbdInputConnections.length; i++)
            MidiKbdConnectionState.internalBinaryWrite(message.kbdInputConnections[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated sushi_rpc.MidiKbdConnectionState kbd_output_connections = 4; */
        for (let i = 0; i < message.kbdOutputConnections.length; i++)
            MidiKbdConnectionState.internalBinaryWrite(message.kbdOutputConnections[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated sushi_rpc.MidiCCConnectionState cc_connections = 5; */
        for (let i = 0; i < message.ccConnections.length; i++)
            MidiCCConnectionState.internalBinaryWrite(message.ccConnections[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated sushi_rpc.MidiPCConnectionState pc_connections = 6; */
        for (let i = 0; i < message.pcConnections.length; i++)
            MidiPCConnectionState.internalBinaryWrite(message.pcConnections[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 enabled_clock_outputs = 7; */
        if (message.enabledClockOutputs.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.enabledClockOutputs.length; i++)
                writer.int32(message.enabledClockOutputs[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.MidiState
 */
export const MidiState = new MidiState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OscParameterState$Type extends MessageType<OscParameterState> {
    constructor() {
        super("sushi_rpc.OscParameterState", [
            { no: 1, name: "processor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "parameter_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<OscParameterState>): OscParameterState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.processor = "";
        message.parameterIds = [];
        if (value !== undefined)
            reflectionMergePartial<OscParameterState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OscParameterState): OscParameterState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string processor */ 1:
                    message.processor = reader.string();
                    break;
                case /* repeated int32 parameter_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.parameterIds.push(reader.int32());
                    else
                        message.parameterIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OscParameterState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string processor = 1; */
        if (message.processor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.processor);
        /* repeated int32 parameter_ids = 2; */
        if (message.parameterIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.parameterIds.length; i++)
                writer.int32(message.parameterIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.OscParameterState
 */
export const OscParameterState = new OscParameterState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OscState$Type extends MessageType<OscState> {
    constructor() {
        super("sushi_rpc.OscState", [
            { no: 1, name: "enable_all_processor_outputs", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "enabled_processor_outputs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OscParameterState }
        ]);
    }
    create(value?: PartialMessage<OscState>): OscState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enableAllProcessorOutputs = false;
        message.enabledProcessorOutputs = [];
        if (value !== undefined)
            reflectionMergePartial<OscState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OscState): OscState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enable_all_processor_outputs */ 1:
                    message.enableAllProcessorOutputs = reader.bool();
                    break;
                case /* repeated sushi_rpc.OscParameterState enabled_processor_outputs */ 2:
                    message.enabledProcessorOutputs.push(OscParameterState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OscState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enable_all_processor_outputs = 1; */
        if (message.enableAllProcessorOutputs !== false)
            writer.tag(1, WireType.Varint).bool(message.enableAllProcessorOutputs);
        /* repeated sushi_rpc.OscParameterState enabled_processor_outputs = 2; */
        for (let i = 0; i < message.enabledProcessorOutputs.length; i++)
            OscParameterState.internalBinaryWrite(message.enabledProcessorOutputs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.OscState
 */
export const OscState = new OscState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackAudioConnectionState$Type extends MessageType<TrackAudioConnectionState> {
    constructor() {
        super("sushi_rpc.TrackAudioConnectionState", [
            { no: 1, name: "track", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "track_channel", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "engine_channel", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TrackAudioConnectionState>): TrackAudioConnectionState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.track = "";
        message.trackChannel = 0;
        message.engineChannel = 0;
        if (value !== undefined)
            reflectionMergePartial<TrackAudioConnectionState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackAudioConnectionState): TrackAudioConnectionState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string track */ 1:
                    message.track = reader.string();
                    break;
                case /* int32 track_channel */ 2:
                    message.trackChannel = reader.int32();
                    break;
                case /* int32 engine_channel */ 3:
                    message.engineChannel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackAudioConnectionState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string track = 1; */
        if (message.track !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.track);
        /* int32 track_channel = 2; */
        if (message.trackChannel !== 0)
            writer.tag(2, WireType.Varint).int32(message.trackChannel);
        /* int32 engine_channel = 3; */
        if (message.engineChannel !== 0)
            writer.tag(3, WireType.Varint).int32(message.engineChannel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.TrackAudioConnectionState
 */
export const TrackAudioConnectionState = new TrackAudioConnectionState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EngineState$Type extends MessageType<EngineState> {
    constructor() {
        super("sushi_rpc.EngineState", [
            { no: 1, name: "sample_rate", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "tempo", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "playing_mode", kind: "message", T: () => PlayingMode },
            { no: 4, name: "sync_mode", kind: "message", T: () => SyncMode },
            { no: 5, name: "time_signature", kind: "message", T: () => TimeSignature },
            { no: 6, name: "clip_detection_input", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "clip_detection_output", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "master_limiter", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "used_audio_inputs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "used_audio_outputs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "input_connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TrackAudioConnectionState },
            { no: 12, name: "output_connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TrackAudioConnectionState }
        ]);
    }
    create(value?: PartialMessage<EngineState>): EngineState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sampleRate = 0;
        message.tempo = 0;
        message.clipDetectionInput = false;
        message.clipDetectionOutput = false;
        message.masterLimiter = false;
        message.usedAudioInputs = 0;
        message.usedAudioOutputs = 0;
        message.inputConnections = [];
        message.outputConnections = [];
        if (value !== undefined)
            reflectionMergePartial<EngineState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EngineState): EngineState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float sample_rate */ 1:
                    message.sampleRate = reader.float();
                    break;
                case /* float tempo */ 2:
                    message.tempo = reader.float();
                    break;
                case /* sushi_rpc.PlayingMode playing_mode */ 3:
                    message.playingMode = PlayingMode.internalBinaryRead(reader, reader.uint32(), options, message.playingMode);
                    break;
                case /* sushi_rpc.SyncMode sync_mode */ 4:
                    message.syncMode = SyncMode.internalBinaryRead(reader, reader.uint32(), options, message.syncMode);
                    break;
                case /* sushi_rpc.TimeSignature time_signature */ 5:
                    message.timeSignature = TimeSignature.internalBinaryRead(reader, reader.uint32(), options, message.timeSignature);
                    break;
                case /* bool clip_detection_input */ 6:
                    message.clipDetectionInput = reader.bool();
                    break;
                case /* bool clip_detection_output */ 7:
                    message.clipDetectionOutput = reader.bool();
                    break;
                case /* bool master_limiter */ 8:
                    message.masterLimiter = reader.bool();
                    break;
                case /* int32 used_audio_inputs */ 9:
                    message.usedAudioInputs = reader.int32();
                    break;
                case /* int32 used_audio_outputs */ 10:
                    message.usedAudioOutputs = reader.int32();
                    break;
                case /* repeated sushi_rpc.TrackAudioConnectionState input_connections */ 11:
                    message.inputConnections.push(TrackAudioConnectionState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated sushi_rpc.TrackAudioConnectionState output_connections */ 12:
                    message.outputConnections.push(TrackAudioConnectionState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EngineState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float sample_rate = 1; */
        if (message.sampleRate !== 0)
            writer.tag(1, WireType.Bit32).float(message.sampleRate);
        /* float tempo = 2; */
        if (message.tempo !== 0)
            writer.tag(2, WireType.Bit32).float(message.tempo);
        /* sushi_rpc.PlayingMode playing_mode = 3; */
        if (message.playingMode)
            PlayingMode.internalBinaryWrite(message.playingMode, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.SyncMode sync_mode = 4; */
        if (message.syncMode)
            SyncMode.internalBinaryWrite(message.syncMode, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.TimeSignature time_signature = 5; */
        if (message.timeSignature)
            TimeSignature.internalBinaryWrite(message.timeSignature, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool clip_detection_input = 6; */
        if (message.clipDetectionInput !== false)
            writer.tag(6, WireType.Varint).bool(message.clipDetectionInput);
        /* bool clip_detection_output = 7; */
        if (message.clipDetectionOutput !== false)
            writer.tag(7, WireType.Varint).bool(message.clipDetectionOutput);
        /* bool master_limiter = 8; */
        if (message.masterLimiter !== false)
            writer.tag(8, WireType.Varint).bool(message.masterLimiter);
        /* int32 used_audio_inputs = 9; */
        if (message.usedAudioInputs !== 0)
            writer.tag(9, WireType.Varint).int32(message.usedAudioInputs);
        /* int32 used_audio_outputs = 10; */
        if (message.usedAudioOutputs !== 0)
            writer.tag(10, WireType.Varint).int32(message.usedAudioOutputs);
        /* repeated sushi_rpc.TrackAudioConnectionState input_connections = 11; */
        for (let i = 0; i < message.inputConnections.length; i++)
            TrackAudioConnectionState.internalBinaryWrite(message.inputConnections[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated sushi_rpc.TrackAudioConnectionState output_connections = 12; */
        for (let i = 0; i < message.outputConnections.length; i++)
            TrackAudioConnectionState.internalBinaryWrite(message.outputConnections[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.EngineState
 */
export const EngineState = new EngineState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginClass$Type extends MessageType<PluginClass> {
    constructor() {
        super("sushi_rpc.PluginClass", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "type", kind: "message", T: () => PluginType },
            { no: 6, name: "state", kind: "message", T: () => ProcessorState }
        ]);
    }
    create(value?: PartialMessage<PluginClass>): PluginClass {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.label = "";
        message.uid = "";
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial<PluginClass>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginClass): PluginClass {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* string uid */ 3:
                    message.uid = reader.string();
                    break;
                case /* string path */ 4:
                    message.path = reader.string();
                    break;
                case /* sushi_rpc.PluginType type */ 5:
                    message.type = PluginType.internalBinaryRead(reader, reader.uint32(), options, message.type);
                    break;
                case /* sushi_rpc.ProcessorState state */ 6:
                    message.state = ProcessorState.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginClass, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* string uid = 3; */
        if (message.uid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.uid);
        /* string path = 4; */
        if (message.path !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.path);
        /* sushi_rpc.PluginType type = 5; */
        if (message.type)
            PluginType.internalBinaryWrite(message.type, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.ProcessorState state = 6; */
        if (message.state)
            ProcessorState.internalBinaryWrite(message.state, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.PluginClass
 */
export const PluginClass = new PluginClass$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackState$Type extends MessageType<TrackState> {
    constructor() {
        super("sushi_rpc.TrackState", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "channels", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "buses", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "type", kind: "message", T: () => TrackType },
            { no: 6, name: "track_state", kind: "message", T: () => ProcessorState },
            { no: 7, name: "processors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PluginClass }
        ]);
    }
    create(value?: PartialMessage<TrackState>): TrackState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.label = "";
        message.channels = 0;
        message.buses = 0;
        message.processors = [];
        if (value !== undefined)
            reflectionMergePartial<TrackState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackState): TrackState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* int32 channels */ 3:
                    message.channels = reader.int32();
                    break;
                case /* int32 buses */ 4:
                    message.buses = reader.int32();
                    break;
                case /* sushi_rpc.TrackType type */ 5:
                    message.type = TrackType.internalBinaryRead(reader, reader.uint32(), options, message.type);
                    break;
                case /* sushi_rpc.ProcessorState track_state */ 6:
                    message.trackState = ProcessorState.internalBinaryRead(reader, reader.uint32(), options, message.trackState);
                    break;
                case /* repeated sushi_rpc.PluginClass processors */ 7:
                    message.processors.push(PluginClass.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* int32 channels = 3; */
        if (message.channels !== 0)
            writer.tag(3, WireType.Varint).int32(message.channels);
        /* int32 buses = 4; */
        if (message.buses !== 0)
            writer.tag(4, WireType.Varint).int32(message.buses);
        /* sushi_rpc.TrackType type = 5; */
        if (message.type)
            TrackType.internalBinaryWrite(message.type, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.ProcessorState track_state = 6; */
        if (message.trackState)
            ProcessorState.internalBinaryWrite(message.trackState, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated sushi_rpc.PluginClass processors = 7; */
        for (let i = 0; i < message.processors.length; i++)
            PluginClass.internalBinaryWrite(message.processors[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.TrackState
 */
export const TrackState = new TrackState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionState$Type extends MessageType<SessionState> {
    constructor() {
        super("sushi_rpc.SessionState", [
            { no: 1, name: "sushi_info", kind: "message", T: () => SushiBuildInfo },
            { no: 2, name: "save_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "osc_state", kind: "message", T: () => OscState },
            { no: 4, name: "midi_state", kind: "message", T: () => MidiState },
            { no: 5, name: "engine_state", kind: "message", T: () => EngineState },
            { no: 6, name: "tracks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TrackState }
        ]);
    }
    create(value?: PartialMessage<SessionState>): SessionState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.saveDate = "";
        message.tracks = [];
        if (value !== undefined)
            reflectionMergePartial<SessionState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionState): SessionState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sushi_rpc.SushiBuildInfo sushi_info */ 1:
                    message.sushiInfo = SushiBuildInfo.internalBinaryRead(reader, reader.uint32(), options, message.sushiInfo);
                    break;
                case /* string save_date */ 2:
                    message.saveDate = reader.string();
                    break;
                case /* sushi_rpc.OscState osc_state */ 3:
                    message.oscState = OscState.internalBinaryRead(reader, reader.uint32(), options, message.oscState);
                    break;
                case /* sushi_rpc.MidiState midi_state */ 4:
                    message.midiState = MidiState.internalBinaryRead(reader, reader.uint32(), options, message.midiState);
                    break;
                case /* sushi_rpc.EngineState engine_state */ 5:
                    message.engineState = EngineState.internalBinaryRead(reader, reader.uint32(), options, message.engineState);
                    break;
                case /* repeated sushi_rpc.TrackState tracks */ 6:
                    message.tracks.push(TrackState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sushi_rpc.SushiBuildInfo sushi_info = 1; */
        if (message.sushiInfo)
            SushiBuildInfo.internalBinaryWrite(message.sushiInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string save_date = 2; */
        if (message.saveDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.saveDate);
        /* sushi_rpc.OscState osc_state = 3; */
        if (message.oscState)
            OscState.internalBinaryWrite(message.oscState, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.MidiState midi_state = 4; */
        if (message.midiState)
            MidiState.internalBinaryWrite(message.midiState, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* sushi_rpc.EngineState engine_state = 5; */
        if (message.engineState)
            EngineState.internalBinaryWrite(message.engineState, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated sushi_rpc.TrackState tracks = 6; */
        for (let i = 0; i < message.tracks.length; i++)
            TrackState.internalBinaryWrite(message.tracks[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sushi_rpc.SessionState
 */
export const SessionState = new SessionState$Type();
/**
 * @generated ServiceType for protobuf service sushi_rpc.SystemController
 */
export const SystemController = new ServiceType("sushi_rpc.SystemController", [
    { name: "GetSushiVersion", options: {}, I: GenericVoidValue, O: GenericStringValue },
    { name: "GetBuildInfo", options: {}, I: GenericVoidValue, O: SushiBuildInfo },
    { name: "GetInputAudioChannelCount", options: {}, I: GenericVoidValue, O: GenericIntValue },
    { name: "GetOutputAudioChannelCount", options: {}, I: GenericVoidValue, O: GenericIntValue }
]);
/**
 * @generated ServiceType for protobuf service sushi_rpc.TransportController
 */
export const TransportController = new ServiceType("sushi_rpc.TransportController", [
    { name: "GetSamplerate", options: {}, I: GenericVoidValue, O: GenericFloatValue },
    { name: "GetPlayingMode", options: {}, I: GenericVoidValue, O: PlayingMode },
    { name: "GetSyncMode", options: {}, I: GenericVoidValue, O: SyncMode },
    { name: "GetTimeSignature", options: {}, I: GenericVoidValue, O: TimeSignature },
    { name: "GetTempo", options: {}, I: GenericVoidValue, O: GenericFloatValue },
    { name: "SetTempo", options: {}, I: GenericFloatValue, O: GenericVoidValue },
    { name: "SetPlayingMode", options: {}, I: PlayingMode, O: GenericVoidValue },
    { name: "SetSyncMode", options: {}, I: SyncMode, O: GenericVoidValue },
    { name: "SetTimeSignature", options: {}, I: TimeSignature, O: GenericVoidValue }
]);
/**
 * @generated ServiceType for protobuf service sushi_rpc.TimingController
 */
export const TimingController = new ServiceType("sushi_rpc.TimingController", [
    { name: "GetTimingsEnabled", options: {}, I: GenericVoidValue, O: GenericBoolValue },
    { name: "SetTimingsEnabled", options: {}, I: GenericBoolValue, O: GenericVoidValue },
    { name: "GetEngineTimings", options: {}, I: GenericVoidValue, O: CpuTimings },
    { name: "GetTrackTimings", options: {}, I: TrackIdentifier, O: CpuTimings },
    { name: "GetProcessorTimings", options: {}, I: ProcessorIdentifier, O: CpuTimings },
    { name: "ResetAllTimings", options: {}, I: GenericVoidValue, O: GenericVoidValue },
    { name: "ResetTrackTimings", options: {}, I: TrackIdentifier, O: GenericVoidValue },
    { name: "ResetProcessorTimings", options: {}, I: ProcessorIdentifier, O: GenericVoidValue }
]);
/**
 * @generated ServiceType for protobuf service sushi_rpc.KeyboardController
 */
export const KeyboardController = new ServiceType("sushi_rpc.KeyboardController", [
    { name: "SendNoteOn", options: {}, I: NoteOnRequest, O: GenericVoidValue },
    { name: "SendNoteOff", options: {}, I: NoteOffRequest, O: GenericVoidValue },
    { name: "SendNoteAftertouch", options: {}, I: NoteAftertouchRequest, O: GenericVoidValue },
    { name: "SendAftertouch", options: {}, I: NoteModulationRequest, O: GenericVoidValue },
    { name: "SendPitchBend", options: {}, I: NoteModulationRequest, O: GenericVoidValue },
    { name: "SendModulation", options: {}, I: NoteModulationRequest, O: GenericVoidValue }
]);
/**
 * @generated ServiceType for protobuf service sushi_rpc.AudioGraphController
 */
export const AudioGraphController = new ServiceType("sushi_rpc.AudioGraphController", [
    { name: "GetAllProcessors", options: {}, I: GenericVoidValue, O: ProcessorInfoList },
    { name: "GetAllTracks", options: {}, I: GenericVoidValue, O: TrackInfoList },
    { name: "GetTrackId", options: {}, I: GenericStringValue, O: TrackIdentifier },
    { name: "GetTrackInfo", options: {}, I: TrackIdentifier, O: TrackInfo },
    { name: "GetTrackProcessors", options: {}, I: TrackIdentifier, O: ProcessorInfoList },
    { name: "GetProcessorId", options: {}, I: GenericStringValue, O: ProcessorIdentifier },
    { name: "GetProcessorInfo", options: {}, I: ProcessorIdentifier, O: ProcessorInfo },
    { name: "GetProcessorBypassState", options: {}, I: ProcessorIdentifier, O: GenericBoolValue },
    { name: "GetProcessorState", options: {}, I: ProcessorIdentifier, O: ProcessorState },
    { name: "SetProcessorBypassState", options: {}, I: ProcessorBypassStateSetRequest, O: GenericVoidValue },
    { name: "SetProcessorState", options: {}, I: ProcessorStateSetRequest, O: GenericVoidValue },
    { name: "CreateTrack", options: {}, I: CreateTrackRequest, O: GenericVoidValue },
    { name: "CreateMultibusTrack", options: {}, I: CreateMultibusTrackRequest, O: GenericVoidValue },
    { name: "CreatePreTrack", options: {}, I: CreatePreTrackRequest, O: GenericVoidValue },
    { name: "CreatePostTrack", options: {}, I: CreatePostTrackRequest, O: GenericVoidValue },
    { name: "CreateProcessorOnTrack", options: {}, I: CreateProcessorRequest, O: GenericVoidValue },
    { name: "MoveProcessorOnTrack", options: {}, I: MoveProcessorRequest, O: GenericVoidValue },
    { name: "DeleteProcessorFromTrack", options: {}, I: DeleteProcessorRequest, O: GenericVoidValue },
    { name: "DeleteTrack", options: {}, I: TrackIdentifier, O: GenericVoidValue }
]);
/**
 * @generated ServiceType for protobuf service sushi_rpc.ProgramController
 */
export const ProgramController = new ServiceType("sushi_rpc.ProgramController", [
    { name: "GetProcessorCurrentProgram", options: {}, I: ProcessorIdentifier, O: ProgramIdentifier },
    { name: "GetProcessorCurrentProgramName", options: {}, I: ProcessorIdentifier, O: GenericStringValue },
    { name: "GetProcessorProgramName", options: {}, I: ProcessorProgramIdentifier, O: GenericStringValue },
    { name: "GetProcessorPrograms", options: {}, I: ProcessorIdentifier, O: ProgramInfoList },
    { name: "SetProcessorProgram", options: {}, I: ProcessorProgramSetRequest, O: GenericVoidValue }
]);
/**
 * @generated ServiceType for protobuf service sushi_rpc.ParameterController
 */
export const ParameterController = new ServiceType("sushi_rpc.ParameterController", [
    { name: "GetTrackParameters", options: {}, I: TrackIdentifier, O: ParameterInfoList },
    { name: "GetProcessorParameters", options: {}, I: ProcessorIdentifier, O: ParameterInfoList },
    { name: "GetParameterId", options: {}, I: ParameterIdRequest, O: ParameterIdentifier },
    { name: "GetParameterInfo", options: {}, I: ParameterIdentifier, O: ParameterInfo },
    { name: "GetParameterValue", options: {}, I: ParameterIdentifier, O: GenericFloatValue },
    { name: "GetParameterValueInDomain", options: {}, I: ParameterIdentifier, O: GenericFloatValue },
    { name: "GetParameterValueAsString", options: {}, I: ParameterIdentifier, O: GenericStringValue },
    { name: "SetParameterValue", options: {}, I: ParameterValue, O: GenericVoidValue },
    { name: "GetTrackProperties", options: {}, I: TrackIdentifier, O: PropertyInfoList },
    { name: "GetProcessorProperties", options: {}, I: ProcessorIdentifier, O: PropertyInfoList },
    { name: "GetPropertyId", options: {}, I: PropertyIdRequest, O: PropertyIdentifier },
    { name: "GetPropertyInfo", options: {}, I: PropertyIdentifier, O: PropertyInfo },
    { name: "GetPropertyValue", options: {}, I: PropertyIdentifier, O: GenericStringValue },
    { name: "SetPropertyValue", options: {}, I: PropertyValue, O: GenericVoidValue }
]);
/**
 * @generated ServiceType for protobuf service sushi_rpc.MidiController
 */
export const MidiController = new ServiceType("sushi_rpc.MidiController", [
    { name: "GetInputPorts", options: {}, I: GenericVoidValue, O: GenericIntValue },
    { name: "GetOutputPorts", options: {}, I: GenericVoidValue, O: GenericIntValue },
    { name: "GetAllKbdInputConnections", options: {}, I: GenericVoidValue, O: MidiKbdConnectionList },
    { name: "GetAllKbdOutputConnections", options: {}, I: GenericVoidValue, O: MidiKbdConnectionList },
    { name: "GetAllCCInputConnections", options: {}, I: GenericVoidValue, O: MidiCCConnectionList },
    { name: "GetAllPCInputConnections", options: {}, I: GenericVoidValue, O: MidiPCConnectionList },
    { name: "GetCCInputConnectionsForProcessor", options: {}, I: ProcessorIdentifier, O: MidiCCConnectionList },
    { name: "GetPCInputConnectionsForProcessor", options: {}, I: ProcessorIdentifier, O: MidiPCConnectionList },
    { name: "GetMidiClockOutputEnabled", options: {}, I: GenericIntValue, O: GenericBoolValue },
    { name: "SetMidiClockOutputEnabled", options: {}, I: MidiClockSetRequest, O: GenericVoidValue },
    { name: "ConnectKbdInputToTrack", options: {}, I: MidiKbdConnection, O: GenericVoidValue },
    { name: "ConnectKbdOutputFromTrack", options: {}, I: MidiKbdConnection, O: GenericVoidValue },
    { name: "ConnectCCToParameter", options: {}, I: MidiCCConnection, O: GenericVoidValue },
    { name: "ConnectPCToProcessor", options: {}, I: MidiPCConnection, O: GenericVoidValue },
    { name: "DisconnectKbdInput", options: {}, I: MidiKbdConnection, O: GenericVoidValue },
    { name: "DisconnectKbdOutput", options: {}, I: MidiKbdConnection, O: GenericVoidValue },
    { name: "DisconnectCC", options: {}, I: MidiCCConnection, O: GenericVoidValue },
    { name: "DisconnectPC", options: {}, I: MidiPCConnection, O: GenericVoidValue },
    { name: "DisconnectAllCCFromProcessor", options: {}, I: ProcessorIdentifier, O: GenericVoidValue },
    { name: "DisconnectAllPCFromProcessor", options: {}, I: ProcessorIdentifier, O: GenericVoidValue }
]);
/**
 * @generated ServiceType for protobuf service sushi_rpc.AudioRoutingController
 */
export const AudioRoutingController = new ServiceType("sushi_rpc.AudioRoutingController", [
    { name: "GetAllInputConnections", options: {}, I: GenericVoidValue, O: AudioConnectionList },
    { name: "GetAllOutputConnections", options: {}, I: GenericVoidValue, O: AudioConnectionList },
    { name: "GetInputConnectionsForTrack", options: {}, I: TrackIdentifier, O: AudioConnectionList },
    { name: "GetOutputConnectionsForTrack", options: {}, I: TrackIdentifier, O: AudioConnectionList },
    { name: "ConnectInputChannelToTrack", options: {}, I: AudioConnection, O: GenericVoidValue },
    { name: "ConnectOutputChannelFromTrack", options: {}, I: AudioConnection, O: GenericVoidValue },
    { name: "DisconnectInput", options: {}, I: AudioConnection, O: GenericVoidValue },
    { name: "DisconnectOutput", options: {}, I: AudioConnection, O: GenericVoidValue },
    { name: "DisconnectAllInputsFromTrack", options: {}, I: TrackIdentifier, O: GenericVoidValue },
    { name: "DisconnectAllOutputFromTrack", options: {}, I: TrackIdentifier, O: GenericVoidValue },
    { name: "DisconnectAllOutputsFromTrack", options: {}, I: TrackIdentifier, O: GenericVoidValue }
]);
/**
 * @generated ServiceType for protobuf service sushi_rpc.CvGateController
 */
export const CvGateController = new ServiceType("sushi_rpc.CvGateController", [
    { name: "GetCvInputChannelCount", options: {}, I: GenericVoidValue, O: GenericIntValue },
    { name: "GetCvOutputChannelCount", options: {}, I: GenericVoidValue, O: GenericIntValue },
    { name: "GetAllCvInputConnections", options: {}, I: GenericVoidValue, O: CvConnectionList },
    { name: "GetAllCvOutputConnections", options: {}, I: GenericVoidValue, O: CvConnectionList },
    { name: "GetAllGateInputConnections", options: {}, I: GenericVoidValue, O: GateConnectionList },
    { name: "GetAllGateOutputConnections", options: {}, I: GenericVoidValue, O: GateConnectionList },
    { name: "GetCvInputConnectionsForProcessor", options: {}, I: ProcessorIdentifier, O: CvConnectionList },
    { name: "GetCvOutputConnectionsForProcessor", options: {}, I: ProcessorIdentifier, O: CvConnectionList },
    { name: "GetGateInputConnectionsForProcessor", options: {}, I: ProcessorIdentifier, O: GateConnectionList },
    { name: "GetGateOutputConnectionsForProcessor", options: {}, I: ProcessorIdentifier, O: GateConnectionList },
    { name: "ConnectCvInputToParameter", options: {}, I: CvConnection, O: GenericVoidValue },
    { name: "ConnectCvOutputFromParameter", options: {}, I: CvConnection, O: GenericVoidValue },
    { name: "ConnectGateInputToProcessor", options: {}, I: GateConnection, O: GenericVoidValue },
    { name: "ConnectGateOutputFromProcessor", options: {}, I: GateConnection, O: GenericVoidValue },
    { name: "DisconnectCvInput", options: {}, I: CvConnection, O: GenericVoidValue },
    { name: "DisconnectCvOutput", options: {}, I: CvConnection, O: GenericVoidValue },
    { name: "DisconnectGateInput", options: {}, I: GateConnection, O: GenericVoidValue },
    { name: "DisconnectGateOutput", options: {}, I: GateConnection, O: GenericVoidValue },
    { name: "DisconnectAllCvInputsFromProcessor", options: {}, I: ProcessorIdentifier, O: GenericVoidValue },
    { name: "DisconnectAllCvOutputsFromProcessor", options: {}, I: ProcessorIdentifier, O: GenericVoidValue },
    { name: "DisconnectAllGateInputsFromProcessor", options: {}, I: ProcessorIdentifier, O: GenericVoidValue },
    { name: "DisconnectAllGateOutputsFromProcessor", options: {}, I: ProcessorIdentifier, O: GenericVoidValue }
]);
/**
 * @generated ServiceType for protobuf service sushi_rpc.OscController
 */
export const OscController = new ServiceType("sushi_rpc.OscController", [
    { name: "GetSendIP", options: {}, I: GenericVoidValue, O: GenericStringValue },
    { name: "GetSendPort", options: {}, I: GenericVoidValue, O: GenericIntValue },
    { name: "GetReceivePort", options: {}, I: GenericVoidValue, O: GenericIntValue },
    { name: "GetEnabledParameterOutputs", options: {}, I: GenericVoidValue, O: OscParameterOutputList },
    { name: "EnableOutputForParameter", options: {}, I: ParameterIdentifier, O: GenericVoidValue },
    { name: "DisableOutputForParameter", options: {}, I: ParameterIdentifier, O: GenericVoidValue },
    { name: "EnableAllOutput", options: {}, I: GenericVoidValue, O: GenericVoidValue },
    { name: "DisableAllOutput", options: {}, I: GenericVoidValue, O: GenericVoidValue }
]);
/**
 * @generated ServiceType for protobuf service sushi_rpc.SessionController
 */
export const SessionController = new ServiceType("sushi_rpc.SessionController", [
    { name: "SaveSession", options: {}, I: GenericVoidValue, O: SessionState },
    { name: "RestoreSession", options: {}, I: SessionState, O: GenericVoidValue }
]);
/**
 * @generated ServiceType for protobuf service sushi_rpc.NotificationController
 */
export const NotificationController = new ServiceType("sushi_rpc.NotificationController", [
    { name: "SubscribeToTransportChanges", serverStreaming: true, options: {}, I: GenericVoidValue, O: TransportUpdate },
    { name: "SubscribeToEngineCpuTimingUpdates", serverStreaming: true, options: {}, I: GenericVoidValue, O: CpuTimings },
    { name: "SubscribeToTrackChanges", serverStreaming: true, options: {}, I: GenericVoidValue, O: TrackUpdate },
    { name: "SubscribeToProcessorChanges", serverStreaming: true, options: {}, I: GenericVoidValue, O: ProcessorUpdate },
    { name: "SubscribeToParameterUpdates", serverStreaming: true, options: {}, I: ParameterNotificationBlocklist, O: ParameterUpdate },
    { name: "SubscribeToPropertyUpdates", serverStreaming: true, options: {}, I: PropertyNotificationBlocklist, O: PropertyValue }
]);
